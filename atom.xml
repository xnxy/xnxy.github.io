<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拿根针尖对麦芒</title>
  
  <subtitle>拿根针尖对麦芒</subtitle>
  <link href="/xnxy.github.io/atom.xml" rel="self"/>
  
  <link href="https://xnxy.github.io/"/>
  <updated>2021-07-04T16:00:00.000Z</updated>
  <id>https://xnxy.github.io/</id>
  
  <author>
    <name>拿根针尖对麦芒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IPA签名检查-iOS15</title>
    <link href="https://xnxy.github.io/2021/06/16/IPA%E7%AD%BE%E5%90%8D%E6%A3%80%E6%9F%A5-iOS15/"/>
    <id>https://xnxy.github.io/2021/06/16/IPA签名检查-iOS15/</id>
    <published>2021-06-15T16:00:00.000Z</published>
    <updated>2021-07-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体内容可以查看官方文档：<a href="https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format" target="_blank" rel="noopener">Using the Latest Code Signature Format</a></p><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>从 iOS 14.2 beta 2 开始，系统会检查新的、更安全的签名格式。启动使用旧格式签名的应用程序的用户会收到警告，提示必须使用新格式重新签名该应用程序。在未来的版本中，新格式将成为强制性的，并且系统不会启动具有旧签名格式的应用程序。</p><p>所以对于开发来说，我们要检测自己打包的IPA的签名是否为新格式签名。</p><h2 id="打包机版本"><a href="#打包机版本" class="headerlink" title="打包机版本"></a>打包机版本</h2><p> 如果打包机的系统为macOS 10.14 或更高版本上打包的程序，理论上是没什么问题，不过为了保险起见，最好还是检测下打包的IPA包。</p><h2 id="检测IPA包是否需要重签名"><a href="#检测IPA包是否需要重签名" class="headerlink" title="检测IPA包是否需要重签名"></a>检测IPA包是否需要重签名</h2><p>在终端中执行下放命令，查找像CodeDirectory v=20500这样的字符串。对于任何v小于20400的值，您需要重新签署您的应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -dv /path/to/MyApp.app</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format#Overview" target="_blank" rel="noopener">Using the Latest Code Signature Format</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体内容可以查看官方文档：&lt;a href=&quot;https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="iOS" scheme="https://xnxy.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于判断App是否运行在Mac上和常用软件整理</title>
    <link href="https://xnxy.github.io/2021/03/15/%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%ADApp%E6%98%AF%E5%90%A6%E8%BF%90%E8%A1%8C%E5%9C%A8Mac%E4%B8%8A%E5%92%8C%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>https://xnxy.github.io/2021/03/15/关于判断App是否运行在Mac上和常用软件整理/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-03-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>在<a href="https://zh.wikipedia.org/wiki/Apple_M1" target="_blank" rel="noopener">苹果M1芯片</a>的Mac上可以运行iOS App，而在Mac的<code>~/Library/Container</code>可以看到沙盒的内容。有时并不需要普通用户看到，所以需要做一些防护。</p><blockquote><p>注：刚重新在新电脑中配置了博客环境，这篇主要是测试博客是否有问题。其内容也很浅显，在网上应该很容易找到。</p><p>重新配置博客环境的时候，想着要不要将博客的主题<code>next</code>更换掉，但是找了一圈，发现并没有合适的,发现还是<code>next</code>比较简洁。</p><p>而且<code>next</code>也有很多人在用，也不太担心后期维护的问题，所以也就保持不变吧。</p></blockquote><h2 id="关于判断应用是否在Mac上运行"><a href="#关于判断应用是否在Mac上运行" class="headerlink" title="关于判断应用是否在Mac上运行"></a>关于判断应用是否在Mac上运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：Swift的API相同。</span><br><span class="line">- (BOOL)isiOSAppOnMac &#123;</span><br><span class="line">    BOOL isiOSAppOnMac = NO;</span><br><span class="line">    if (@available(iOS 14.0, *)) &#123;</span><br><span class="line">        isiOSAppOnMac = [NSProcessInfo processInfo].isiOSAppOnMac;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于如何将App运行到Mac上"><a href="#关于如何将App运行到Mac上" class="headerlink" title="关于如何将App运行到Mac上"></a>关于如何将App运行到Mac上</h2><blockquote><p>1、导出.app文件。</p></blockquote><p>这里我们可以使用<a href="https://imazing.com" target="_blank" rel="noopener">iMazing</a>导出。</p><p>当然也可以使用<code>Apple Configurator 2</code>这个软件,不过个人认为这个软件并没有<a href="https://imazing.com" target="_blank" rel="noopener">iMazing</a>好用。</p><blockquote><p>2、将.app文件拖到应用程序</p></blockquote><p>将.app拖到应用程序中，此时双击并不能打开，需要执行下方命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注：*** 为app名称</span><br><span class="line">sudo xattr -rd com.apple.quarantine /Applications/***.app</span><br></pre></td></tr></table></figure><p>然后双击即可打开app。</p><blockquote><p>3、查看沙盒目录。</p></blockquote><p>原有的沙盒内容目前在资源库中，可以打开查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Container</span><br></pre></td></tr></table></figure><p>感觉这点做的不太好，毕竟沙盒机制很安全，目前相当于所有沙盒内容到暴露在用户面前了。</p><hr><h2 id="常用软件记录"><a href="#常用软件记录" class="headerlink" title="常用软件记录"></a>常用软件记录</h2><p>这里主要整理一下常用的软件，不想再重新开文了，就都放到一篇文章中了。</p><h3 id="iMazing"><a href="#iMazing" class="headerlink" title="iMazing"></a><a href="https://imazing.com" target="_blank" rel="noopener">iMazing</a></h3><p><code>iMazing</code>类似于苹果端的手机助手，目前主要使用他导出手机上的IPA文件。还有就是安装IPA。</p><p>其实还有像<code>爱思助手</code>之类的软件，但感觉并不是很友好。</p><h3 id="checkra1n"><a href="#checkra1n" class="headerlink" title="checkra1n"></a><a href="https://checkra.in/" target="_blank" rel="noopener">checkra1n</a></h3><p><code>checkra1n</code> 可以在iPhone X，iOS 12.0及更高版本的iPhone 5s上进行越狱。</p><p>一个很厉害的软件。我这边只测试过<code>iPhone 6s</code>，可以稳定的越狱。至于<code>iPhone X</code>及以上设备，这边并没有测试过，不过在推特上看到有人测试过，也是可以稳定越狱。</p><h3 id="Hopper-Disassemble"><a href="#Hopper-Disassemble" class="headerlink" title="Hopper Disassemble"></a><a href="https://www.hopperapp.com/" target="_blank" rel="noopener">Hopper Disassemble</a></h3><p>逆向工程工具，可让您反汇编，反编译和调试应用程序。可以跟<a href="https://www.hex-rays.com/products/ida/support/download_freeware/" target="_blank" rel="noopener">IDA</a>配合使用。</p><h3 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a><a href="https://www.hex-rays.com/products/ida/support/download_freeware/" target="_blank" rel="noopener">IDA</a></h3><p>逆向工程工具。</p><h3 id="charles"><a href="#charles" class="headerlink" title="charles"></a><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">charles</a></h3><p>抓包工具。</p><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a><a href="https://apps.apple.com/cn/app/stream/id1312141691" target="_blank" rel="noopener">stream</a></h3><p>手机端、IPA端的抓包工具，使用比较方便。</p><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a><a href="https://revealapp.com/" target="_blank" rel="noopener">Reveal</a></h3><p>UI检查工具。</p><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a><a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">postman</a></h3><p>接口调试工具。</p><h3 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a></h3><p>git管理工具。</p><h3 id="SmartSVN"><a href="#SmartSVN" class="headerlink" title="SmartSVN"></a><a href="https://www.smartsvn.com/" target="_blank" rel="noopener">SmartSVN</a></h3><p>SVN管理工具。</p><h3 id="Trojan"><a href="#Trojan" class="headerlink" title="Trojan"></a><a href="https://github.com/JimLee1996/TrojanX" target="_blank" rel="noopener">Trojan</a></h3><p><a href="https://github.com/trojan-gfw/trojan" target="_blank" rel="noopener">Trojan</a>的macOS客户端。</p><h3 id="关于VPN"><a href="#关于VPN" class="headerlink" title="关于VPN"></a>关于VPN</h3><p>如果使用<a href="https://order.yizhihongxing.network/aff.php?aff=4651" target="_blank" rel="noopener">VPN</a>个人推荐<a href="https://order.yizhihongxing.network/aff.php?aff=4651" target="_blank" rel="noopener">一支红杏</a>，因为这个用了很多年，还是比较稳定的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://imazing.com" target="_blank" rel="noopener">iMazing</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/Apple_
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>EasyOCR用户协议</title>
    <link href="https://xnxy.github.io/2020/11/04/EasyOCR%E7%94%A8%E6%88%B7%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xnxy.github.io/2020/11/04/EasyOCR用户协议/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2020-11-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EasyOCR用户协议"><a href="#EasyOCR用户协议" class="headerlink" title="EasyOCR用户协议"></a>EasyOCR用户协议</h1><h2 id="一、声明"><a href="#一、声明" class="headerlink" title="一、声明"></a>一、声明</h2><p>任何单位或个人在使用EasyOCR APP之前（以下简称“EasyOCR”），均应仔细阅读本条款，如不同意本条款可停止使用EasyOCR，一旦使用，即被视为对本条款全部内容的认可和接受。</p><h2 id="二、关于获取隐私"><a href="#二、关于获取隐私" class="headerlink" title="二、关于获取隐私"></a>二、关于获取隐私</h2><p>EasyOCR只访问数据，不会对数据进行上传。</p><ol><li>EasyOCR需要您允许访问相机，以便于拍照进行文字识别；</li><li>EasyOCR需要您允许访问相册，以便于选择图片进行识别。</li></ol><h2 id="二、风险与免责"><a href="#二、风险与免责" class="headerlink" title="二、风险与免责"></a>二、风险与免责</h2><p>若因下列事件导致您的隐私泄露，我们将尽最大努力进行补救或为您提供协助，但您同意我们无需承担任何责任。</p><ol><li>因病毒、木马、黑客攻击而导致的信息泄露；</li><li>任何其他非因EasyOCR的原因导致的个人信息泄漏；</li></ol><h2 id="三、隐私条款更改"><a href="#三、隐私条款更改" class="headerlink" title="三、隐私条款更改"></a>三、隐私条款更改</h2><p>EasyOCR可根据国家法律法规变化及维护用户权益需要，不时修改本条款，变更后的条款将通过法定程序在本条款中标明最后更新日期。</p><blockquote><p>更新日期：2020年11月04日</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EasyOCR用户协议&quot;&gt;&lt;a href=&quot;#EasyOCR用户协议&quot; class=&quot;headerlink&quot; title=&quot;EasyOCR用户协议&quot;&gt;&lt;/a&gt;EasyOCR用户协议&lt;/h1&gt;&lt;h2 id=&quot;一、声明&quot;&gt;&lt;a href=&quot;#一、声明&quot; class=&quot;
      
    
    </summary>
    
      <category term="个人项目" scheme="https://xnxy.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>EasyOCR技术支持</title>
    <link href="https://xnxy.github.io/2020/11/04/EasyOCR%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    <id>https://xnxy.github.io/2020/11/04/EasyOCR技术支持/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2020-11-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产品简介"><a href="#产品简介" class="headerlink" title="产品简介"></a>产品简介</h2><p>EasyOCR是一款专业的本地OCR图片文字识别APP。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/EasyOCR/001.png" alt="首页"><br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/EasyOCR/002.png" alt="调整角度"><br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/EasyOCR/004.png" alt="裁剪图片"><br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/EasyOCR/003.png" alt="识别结果"></p><h2 id="关于隐私"><a href="#关于隐私" class="headerlink" title="关于隐私"></a>关于隐私</h2><p>EasyOCR完全进行本地识别，不会将图片上传服务器，不会保存任何信息，不会泄露个人隐私。</p><h2 id="关于EasyOCR"><a href="#关于EasyOCR" class="headerlink" title="关于EasyOCR"></a>关于EasyOCR</h2><p>EasyOCR底层基于PaddleOCR训练的模型，识别速度高，目前支持中英文数字组合识别、竖排文本识别、长文本识别。</p><h2 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h2><p>进入首页选择拍照识别（相册识别）-&gt; 调整角度（右上角裁剪）-&gt;点击识别按钮-&gt;进入识别结果页面，将内容复制剪贴板（右上角复制全部内容到剪切板）</p><h2 id="关于帮助"><a href="#关于帮助" class="headerlink" title="关于帮助"></a>关于帮助</h2><p>感谢您使用EasyOCR，在使用过程中如果有任何问题可以通过以下方式联系我寻求帮助：</p><ol><li>个人邮箱：<a href="mailto:2303400083@qq.com" target="_blank" rel="noopener">2303400083@qq.com</a></li><li>微信公众号：拿根针尖对麦芒（ZhouWeiTalk）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;产品简介&quot;&gt;&lt;a href=&quot;#产品简介&quot; class=&quot;headerlink&quot; title=&quot;产品简介&quot;&gt;&lt;/a&gt;产品简介&lt;/h2&gt;&lt;p&gt;EasyOCR是一款专业的本地OCR图片文字识别APP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-zho
      
    
    </summary>
    
      <category term="个人项目" scheme="https://xnxy.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于HMAC签名相关</title>
    <link href="https://xnxy.github.io/2020/11/04/%E5%85%B3%E4%BA%8EHMAC%E7%AD%BE%E5%90%8D%E7%9B%B8%E5%85%B3/"/>
    <id>https://xnxy.github.io/2020/11/04/关于HMAC签名相关/</id>
    <published>2020-11-03T16:00:00.000Z</published>
    <updated>2020-11-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>节后有个项目使用到腾讯云的<a href="https://cloud.tencent.com/document/product/1007/35330" target="_blank" rel="noopener">活体检测</a>，其实功能也不是很复杂，但在对接腾讯云的时候被他的<a href="https://cloud.tencent.com/document/api/1007/31325" target="_blank" rel="noopener">签名</a>方式耽误了一些时间，但好在它的文档写的很详细，仔细地阅读了官方文档，最后也在很快的时间内对接成功。</p><p>这里主要记录<code>HMAC-SHA1</code>在iOS中的代码，便于后期查阅。</p><blockquote><p>引入头文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;CommonCrypto/CommonDigest.h&gt;</span><br><span class="line">#include &lt;CommonCrypto/CommonHMAC.h&gt;</span><br></pre></td></tr></table></figure><blockquote><p> <code>HMAC-SHA1</code>算法签名,<code>Base64</code>进行编码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)hmacsha1:(NSString *)obj key:(NSString *)key &#123;</span><br><span class="line">    const char *cKey  = [key cStringUsingEncoding:NSASCIIStringEncoding];</span><br><span class="line">    const char *cData = [obj cStringUsingEncoding:NSASCIIStringEncoding];</span><br><span class="line">    unsigned char cHMAC[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line"></span><br><span class="line">    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);</span><br><span class="line">    NSData *HMAC = [[NSData alloc] initWithBytes:cHMAC</span><br><span class="line">                                          length:sizeof(cHMAC)];</span><br><span class="line"></span><br><span class="line">    NSString *hash = [HMAC base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];</span><br><span class="line"></span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://baike.baidu.com/item/hmac" target="_blank" rel="noopener">hmac-百度百科</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;节后有个项目使用到腾讯云的&lt;a href=&quot;https://cloud.tencent.co
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LLVM编译流程等相关知识整理</title>
    <link href="https://xnxy.github.io/2020/10/07/LLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E7%AD%89%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://xnxy.github.io/2020/10/07/LLVM编译流程等相关知识整理/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-12-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>整理这篇博客主要是了解iOS编译的过程，了解其相关知识，丰富自己的知识体系。</p><p>在写这篇博客之前查看了<a href="https://ke.qq.com/mobilev2/courseDetail.html?_bid=167&_wv=3&course_id=322016&from=share#from=iosapp" target="_blank" rel="noopener">李明杰在腾讯课堂的关于LLVM的付费课程</a>,<a href="http://www.hzcourse.com/web/teachRes/detail/4635/231" target="_blank" rel="noopener">《LLVM编译器实战教程》</a>相关书籍，还有网络上一些博客，在此向他们致敬！</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/LLVM%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/LLVM.png" alt="LLVM"></p><h2 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是LLVM</h2><p><code>LLVM</code>项目是模块化、可重用的<code>编译器</code>以及<code>工具链</code>技术的集合。</p><p><code>LLVM</code>跟传统的静态编译器一样使用了经典三段式的结构设计，如下图所示，分别为前端、优化器和后端。</p><blockquote><p>传统编译器架构</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/LLVM%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/LLVM%E6%9E%B6%E6%9E%84.jpg" alt="传统编译器架构"></p><ul><li><code>Frontend（编译器前端）</code>：进行词法分析、语法分析、语义分析、生成中间代码<code>（IR）</code>。</li><li><code>Optimizer（优化器）</code>：中间代码优化。</li><li><code>Backend（后端）</code>:生成机器码</li></ul><p><code>LLVM</code>编译器如这篇文章的头图所示。这样做的优点如下：</p><ul><li>如果需要支持一种新的编程语言，只需要实现一种新的编译器前端即可。</li><li>如果需要支持一种新的硬件设备，只需要实现一个新的后端即可。</li><li>优化阶段是一个通用的阶段，它针对的是统一的<code>LLVM IR</code>,不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段进行修改。</li></ul><h2 id="什么是Clang"><a href="#什么是Clang" class="headerlink" title="什么是Clang"></a>什么是Clang</h2><p><code>Clang</code>是<code>LLVM项目</code>的一个<code>子项目</code>，是基于<code>LLVM</code>架构的<code>C/C++/Objective-C</code>编译器<code>前端</code>。</p><h2 id="Clang常用指令"><a href="#Clang常用指令" class="headerlink" title="Clang常用指令"></a><code>Clang</code>常用指令</h2><p><code>Clang</code>工具可以再<code>Xcode</code>中查看，具体路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang</span><br></pre></td></tr></table></figure><p>可以再终端输入<code>Clang -help</code>查看所有指令。</p><p>常用的指令如下所示：</p><ul><li>生成可执行文件:<code>clang main.o -o main</code></li><li>查看编译过程：<code>clang -ccc-print-phases main.m</code></li><li>查看预处理结果：<code>clang -E main.m</code></li><li>语法分析,生成Token:<code>clang -fmodules -E -Xclang -dump-tokens main.m</code></li><li>生成语法树(AST):<code>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></li><li>LLVM中间表示层(LLVM IR)：<code>clang -S -fobjc-arc -emit-llvm main.m -o main.ll</code></li><li>生成汇编：<code>clang -S -fobjc-arc main.m -o main.s</code></li><li>生成目标文件：<code>clang -fmodules -c main.m -o main.o</code></li></ul><h2 id="swiftc常用指令"><a href="#swiftc常用指令" class="headerlink" title="swiftc常用指令"></a><code>swiftc</code>常用指令</h2><p><code>swiftc</code>工具可以在<code>Xcode</code>中查看,具体路径为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc</span><br></pre></td></tr></table></figure><p>可以在终端输入<code>swiftc -help</code>查看相关指令。</p><p>常用的指令如下所示：</p><ul><li>生成可执行文件:<code>swiftc -o main.out main.swift</code></li><li>生成抽象语法树（AST）:<code>swiftc main.swift -dump-ast</code></li><li>生成中间语言(SIL)：<code>swiftc main.swift -emit-sil</code></li><li>LLVM中间表示层(LLVM IR)：<code>swiftc main.swift -emit -ir</code></li><li>生成汇编:<code>swiftc main.swift -emit-assembly</code></li></ul><h2 id="App编译过程"><a href="#App编译过程" class="headerlink" title="App编译过程"></a>App编译过程</h2><ol><li>编译信息写入辅助文件，创建文件架构 .app 文件</li><li>处理文件打包信息</li><li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li><li>编译.m文件，使用 CompileC 和 clang 命令</li><li>链接需要的 Framework</li><li>编译 xib</li><li>拷贝 xib ，资源文件</li><li>编译 ImageAssets</li><li>处理 info.plist</li><li>执行 CocoaPod 脚本</li><li>拷贝标准库</li><li>创建 .app 文件和签名</li></ol><h2 id="Swift语言编译过程"><a href="#Swift语言编译过程" class="headerlink" title="Swift语言编译过程"></a>Swift语言编译过程</h2><p>Swift编译前端使用的是<code>swiftc</code>,其中<code>Swift</code>前端会多出<code>SIL optimizer</code>，它会将<code>*.swift</code>生成的中间代码<code>*.sil</code>设置成<code>High-Level IR</code>。</p><p>因为<code>swift</code>在编译时就完成了方法绑定直接通过地址调用，属于强类型语言。方法调用也不像OC那样进行消息转发，这样编译就可以获得更多的信息用在后端的优化上。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/LLVM%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/Swift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="Swift编译过程"></p><h2 id="关于LinkMap"><a href="#关于LinkMap" class="headerlink" title="关于LinkMap"></a>关于<code>LinkMap</code></h2><p><code>Link Map File</code>其实就是链接的映射文件，它是在Xcode生成可执行文件的同时生成的链接信息文件，用于描述可执行文件的构造部分，包含了代码段和数据段的分布情况。</p><blockquote><p>Object files</p></blockquote><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p><blockquote><p>Sections</p></blockquote><p>这里描述的是每个 Section在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为<code>__TEXT</code>代码段和<code>__DATA</code> 数据段两种。</p><blockquote><p>Symbols</p></blockquote><p><code>Symbols</code>是对<code>Sections</code>进行了再划分。这里会描述所有的<code>methods</code>，<code>ivar</code>和字符串，及它们对应的地址，大小，文件编号信息。</p><h2 id="关于符号表dSYM"><a href="#关于符号表dSYM" class="headerlink" title="关于符号表dSYM"></a>关于符号表<code>dSYM</code></h2><p>符号表是内存地址与函数名、文件名、行号的映射表。符号表的元素如下所示：</p><p><code>&lt;起始地址&gt;&lt;结束地址&gt;&lt;函数&gt;[&lt;文件名：行号&gt;]</code></p><p>一般打包完成后会保存符号表文件，后期可以通过<code>堆栈</code>进行解析和还原，来定位用户APP发生<code>Crash</code>的代码位置。</p><blockquote><p>可以参考<a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=20180119105842" target="_blank" rel="noopener">Bugly相关文档</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://llvm.org" target="_blank" rel="noopener">LLVM官网</a></li><li><a href="http://clang.llvm.org" target="_blank" rel="noopener">Clang官网</a></li><li><a href="http://www.hzcourse.com/web/teachRes/detail/4635/231" target="_blank" rel="noopener">《LLVM编译器实战教程》</a></li><li><a href="https://llvm.comptechs.cn/" target="_blank" rel="noopener">LLVM中文网</a></li><li><a href="https://developer.aliyun.com/article/727296" target="_blank" rel="noopener">带你读《LLVM编译器实战教程》之一：构建和安装LLVM</a></li><li><a href="https://developer.aliyun.com/article/727298" target="_blank" rel="noopener">带你读《LLVM编译器实战教程》之二：外部项目</a></li><li><a href="https://developer.aliyun.com/article/727299" target="_blank" rel="noopener">带你读《LLVM编译器实战教程》之三：工具和设计</a></li><li><a href="https://releases.llvm.org" target="_blank" rel="noopener">llvm</a></li><li><a href="https://blog.csdn.net/snsn1984/category_9263298.html" target="_blank" rel="noopener">深入研究Clang</a></li><li><a href="https://www.oschina.net/p/llvm?hmsr=aladdin1e1" target="_blank" rel="noopener">LLVM编译器架构</a></li><li><a href="https://www.jianshu.com/p/9fc7776cce9b" target="_blank" rel="noopener">深入剖析iOS编译Clang/LLVM</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;整理这篇博客主要是了解iOS编译的过程，了解其相关知识，丰富自己的知识体系。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Xcode12项目适配</title>
    <link href="https://xnxy.github.io/2020/09/24/Xcode12%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D/"/>
    <id>https://xnxy.github.io/2020/09/24/Xcode12项目适配/</id>
    <published>2020-09-23T16:00:00.000Z</published>
    <updated>2020-09-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>最近更新Xcode12，发现编译有的项目的时候会出现些问题，然后一个个解决所有项目完美编译通过。</p><p>最近看有的群里在讨论Xcode12编译项目的一些问题，觉得可以整理一篇自己遇到问题的文章，便于遇到同样问题的朋友查阅。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><blockquote><p>项目无法在模拟器中运行</p></blockquote><p>将项目运行到模拟器的时候报<code>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=arm64 armv7)</code>错误。</p><p>修复：</p><p>TARGETS-&gt;Build Settings-&gt;搜索<code>VALID_ARCHS</code>, 然后添加模拟器的指令集。如果有多个TARGETS时，需要分别添加。</p><p>如图所示：<br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/Xcode12%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D/%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%80%82%E9%85%8D.jpg" alt="项目运行模拟器适配"></p><blockquote><p>Library not found for -lstdc++.6.0.9</p></blockquote><p>果然自己保存在github中的<code>lstdc++</code>库是对的，忘记从哪个版本Xcode去除了<code>lstdc++</code>库，每次更新Xcode的时候都需要重新添加一下。</p><p>修复：</p><ul><li>从<a href="https://github.com/xnxy/libsted-.git" target="_blank" rel="noopener">github</a>中下载<code>lstdc++</code>，将其复制到下面的路径下即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/</span><br><span class="line"></span><br><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>Swift代码中报<code>Constructing an object of class type &#39;Self&#39; with a metatype value must use a &#39;required&#39; initializer。错误</code></p><p>修复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init() &#123;</span><br><span class="line">   super.init(</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;最近更新Xcode12，发现编译有的项目的时候会出现些问题，然后一个个解决所有项目完美编译通
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS14隐私权限适配及其他</title>
    <link href="https://xnxy.github.io/2020/09/14/iOS14%E9%9A%90%E7%A7%81%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%E5%8F%8A%E5%85%B6%E4%BB%96/"/>
    <id>https://xnxy.github.io/2020/09/14/iOS14隐私权限适配及其他/</id>
    <published>2020-09-13T16:00:00.000Z</published>
    <updated>2020-09-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>在<a href="https://developer.apple.com/videos/wwdc2020/" target="_blank" rel="noopener">WWDC2020</a>发布会上苹果展示了新的<a href="https://developer.apple.com/cn/ios/" target="_blank" rel="noopener">iOS14</a>系统。对于iOS开发工程师来说，适配iOS14其重点在于隐私权限的适配。具体内容可以观看<a href="https://developer.apple.com/videos/play/wwdc2020/10676/" target="_blank" rel="noopener">WWDC2020中：建立更好的隐私信任</a>的视频进行了解。</p><blockquote><p>note:截止目前，适配<code>iOS14</code>需要更新mac系统到<code>11  beta 6</code>、xcode需要更新到<code>12 beta 6</code>、手机需要更新到<code>14 beta 8</code>，相关版本可以到<a href="https://developer.apple.com/download/#ios-restore-images-iphone-new" target="_blank" rel="noopener">苹果官网下载</a>；更新beta版本打包可能会影响正常上架，该问题未进行测试，但需要引起注意。</p></blockquote><h1 id="广告标识符的获取"><a href="#广告标识符的获取" class="headerlink" title="广告标识符的获取"></a>广告标识符的获取</h1><p>广告标识符(Identity for Advertisers)简称<code>IDFA</code>，主要用来标记用户。在<code>iOS14</code>系统中，系统会默认关闭广告标跟踪权限。如果在开发中使用，需要向用户请求权限，步骤如下：</p><blockquote><p>1、info.plist配置</p></blockquote><p>选中<code>info.plist</code>右键<code>Open As</code>-&gt;<code>Source Code</code> 然后将下方配置和描述信息添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSUserTrackingUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;“太平通宝”需要您允许访问广告标识符权限，以便于追踪广告和信息的推送&lt;/string&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2、头文件引入</p></blockquote><p>为了适配低版本Xcode编译，需要使用预编译命令,所以头文件引入方式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__IPHONE_14_0)</span><br><span class="line">#import &lt;AppTrackingTransparency/AppTrackingTransparency.h&gt;//适配iOS14</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>3、获取IDFA</p></blockquote><p><code>iOS14</code>及以上系统，需要先请求跟踪权限，用户同意后才能获取广告标识。获取方法标识符的代码<code>iOS14</code>之前一样。示例代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)idfaString &#123;</span><br><span class="line">    __block NSString *idfa;</span><br><span class="line">#if defined(__IPHONE_14_0)</span><br><span class="line">    if (@available(iOS 14, *)) &#123;</span><br><span class="line">        // iOS14及以上版本需要先请求权限</span><br><span class="line">        ATTrackingManagerAuthorizationStatus status = ATTrackingManager.trackingAuthorizationStatus;</span><br><span class="line">        if (status == ATTrackingManagerAuthorizationStatusNotDetermined) &#123; //用户未做选择或未弹窗</span><br><span class="line">            dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">            [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) &#123;</span><br><span class="line">                // 获取到权限后，依然使用老方法获取idfa</span><br><span class="line">                if (status == ATTrackingManagerAuthorizationStatusAuthorized) &#123; //用户允许</span><br><span class="line">                    idfa = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">                    ICLog(@&quot;--iOS14----%@----&quot;,idfa);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_semaphore_signal(sem);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;else if(status == ATTrackingManagerAuthorizationStatusAuthorized)&#123;//用户允许</span><br><span class="line">            idfa = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ICLog(@&quot;请在设置-隐私-Tracking中允许App请求跟踪&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    // iOS14以下版本依然使用老方法</span><br><span class="line">    // 判断在设置-隐私里用户是否打开了广告跟踪</span><br><span class="line">    if ([[ASIdentifierManager sharedManager] isAdvertisingTrackingEnabled]) &#123;</span><br><span class="line">        idfa = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">        ICLog(@&quot;---iOS14以下系统----%@-----&quot;,idfa);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ICLog(@&quot;请在设置-隐私-广告中打开广告跟踪功能&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    idfa = (idfa ? : @&quot;&quot;);</span><br><span class="line">    return idfa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h1><p>iOS14中新增了个<code>有限的图片库访问</code>模式，在授权弹窗的时候会新增个<code>Select Photo</code>选项，用户可以选择一部分图片供App读取，而App无法获取相册中的所有图片信息。</p><p>如果用户使用了<code>有限图片库访问</code>(Limited Photo Library Access)的模式, 如果App不进行适配，权限提示框会在每次冷启动打开相册的时候重新弹出，我们需要在<code>info.plist</code>中进行配置，关闭弹窗。</p><blockquote><p>1、info.plist配置</p></blockquote><p>选中<code>info.plist</code>右键<code>Open As</code>-&gt;<code>Source Code</code> 然后将下方配置和描述信息添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;PHPhotoLibraryPreventAutomaticLimitedAccessAlert&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br></pre></td></tr></table></figure><p>当然，我们也可以通过相应API来控制何时弹出图片选择的弹出。API如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[PHPhotoLibrary sharedPhotoLibrary] presentLimitedLibraryPickerFromViewController:self];</span><br></pre></td></tr></table></figure><p>同时，在iOS14中官方推荐使用苹果推荐使用<code>PHPicker</code>来代替原API来选择图片。</p><p>关于<code>PHPicker</code>的介绍可以参看<a href="https://developer.apple.com/videos/play/wwdc2020/10652/" target="_blank" rel="noopener">WWDC2020：认识新的照片选择器</a>的相关介绍。</p><h1 id="位置信息"><a href="#位置信息" class="headerlink" title="位置信息"></a>位置信息</h1><p>在iOS14中，苹果新增了<code>模糊定位</code>的概念。原因是苹果认为很多APP并不需要获取用户的<code>精准定位</code>。所以在iOS14授权弹窗的时候新增了<code>Precise</code>的精准开关，默认会选中精准位置，用户可以通过这个开关进行更改。</p><h2 id="对于地理位置敏感的APP"><a href="#对于地理位置敏感的APP" class="headerlink" title="对于地理位置敏感的APP"></a>对于地理位置敏感的APP</h2><blockquote><p>1、info.plist配置</p></blockquote><p>不过对于需要精准定位的App需要在<code>info.plist</code>中设置<code>NSLocationTemporaryUsageDescriptionDictionary</code>字典，key为<code>purposeKey</code>,value为对应获取<code>精准定位</code>的原因。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSLocationTemporaryUsageDescriptionDictionary&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;punchTheClock&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;“太平通宝”需要您允许精准定位，以便于使用打卡功能&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2、获取单次精准定位</p></blockquote><p>同时需要调用相应API，获取精准定位。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CALocationMnanger requestTemporaryFullAccuracyAuthorizationWithPurposeKey:@&quot;punchTheClock&quot;]</span><br></pre></td></tr></table></figure><h2 id="对于地理位置不敏感的App"><a href="#对于地理位置不敏感的App" class="headerlink" title="对于地理位置不敏感的App"></a>对于地理位置不敏感的App</h2><p>对定位信息不敏感的APP，iOS14中可以直接在<code>info.plist</code>中添加<code>NSLocationDefaultAccuracyReduced</code>为<code>true</code>,默认请求<code>模糊定位</code>。</p><p>选中<code>info.plist</code>右键<code>Open As</code>-&gt;<code>Source Code</code> 然后将下方配置和描述信息添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSLocationDefaultAccuracyReduced&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br></pre></td></tr></table></figure><h1 id="Local-Network"><a href="#Local-Network" class="headerlink" title="Local Network"></a>Local Network</h1><p>iOS14中新增了<code>Local Network</code>权限提示，具体关于<code>Local Network</code>的相关信息可以查看<a href="https://developer.apple.com/videos/play/wwdc2020/10110/" target="_blank" rel="noopener">苹果官网的视频</a>或者<code>少数派</code>的关于<a href="https://zhuanlan.zhihu.com/p/157159226?from_voters_page=true" target="_blank" rel="noopener">iOS14新增的本地网络权限，要开给第三方App吗?</a>等相关资料。</p><h1 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h1><p>在iOS14中，如果APP读取剪切版的内容时，手机会弹出提示，提示哪个APP在获取剪切板内容。</p><h1 id="相机和麦克风"><a href="#相机和麦克风" class="headerlink" title="相机和麦克风"></a>相机和麦克风</h1><p>在iOS14中APP如果使用相机和麦克风，手机的的上方会有绿色和黄色的提示，同时也可以查看是哪个APP在使用相机和麦克风。</p><p>关于该功能开发人员无法控制。</p><h1 id="UIDatePicker更新UI样式"><a href="#UIDatePicker更新UI样式" class="headerlink" title="UIDatePicker更新UI样式"></a>UIDatePicker更新UI样式</h1><p>在iOS14中，<code>UIDatePicker</code>的样式新增了<code>UIDatePickerStyleInline</code>，而且为默认值。如果项目中使用了<code>UIDatePicker</code>，而且希望使用原来的样式，需要设置其样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.pickerView.preferredDatePickerStyle = UIDatePickerStyleWheels;</span><br></pre></td></tr></table></figure><h1 id="UITableViewCell适配"><a href="#UITableViewCell适配" class="headerlink" title="UITableViewCell适配"></a>UITableViewCell适配</h1><blockquote><p>UITableViewCell无法点击</p></blockquote><p>在Xcode12、iOS14中，如果在UITableViewCell渲染前没有调用<code>self.contentView</code>，系统会在渲染完<code>UITableViewCell</code>上的控件后在其上方添加<code>contentView</code>，这会使<code>contentView</code>拦截住<code>UITableViewCell</code>控件的响应事件。</p><p>其解决方式是将<code>UITableViewCell</code>上的控件添加到<code>self.contentView</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self addSubview:view];</span><br><span class="line">改为：</span><br><span class="line">[self.contentView addSubview:view];</span><br></pre></td></tr></table></figure><blockquote><p>hook修复UITableViewCell无法点击问题</p></blockquote><p>虽然上方的方法可以修复UITableViewCell无法点击问题，但对于一个很庞大的项目来说，不确定是否有遗漏，尤其是一些组件。所以在项目中需要用到<code>修改+hook</code>的方式。</p><p>方法也很简单，直接hook住<code>UITableViewCell</code>中的<code>addSubview：</code>方法，全局修复下即可，同时后期写代码也要注意代码规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UITableViewCell+TB.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UITableViewCell (TB)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    Method method1 = class_getInstanceMethod([self class], NSSelectorFromString(@&quot;addSubview:&quot;));</span><br><span class="line">    Method method2 = class_getInstanceMethod([self class], @selector(tb_addSubview:));</span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addSubview:(UIView *)view&#123;</span><br><span class="line">    [super addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tb_addSubview:(UIView *)view &#123;</span><br><span class="line">    if  ([view isKindOfClass:NSClassFromString(@&quot;UITableViewCellContentView&quot;)]) &#123;</span><br><span class="line">        [self tb_addSubview:view];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.contentView addSubview:view];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>UITableViewCell 背景色变成灰色</p></blockquote><p>灰色为<code>self.contentView</code>的背景色，在init方法中共添加即可。</p><h1 id="YYAnimatedImageView-无法加载图片"><a href="#YYAnimatedImageView-无法加载图片" class="headerlink" title="YYAnimatedImageView 无法加载图片"></a>YYAnimatedImageView 无法加载图片</h1><p>因为项目中用到<code>YYImage</code>第三方库。</p><p>解决方式：<br>修复：YYAnimatedImageView.m 529行的函数修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)layer &#123;</span><br><span class="line">    if (_curFrame) &#123;</span><br><span class="line">        layer.contents = (__bridge id)_curFrame.CGImage;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (@available(iOS 14.0, *)) &#123;</span><br><span class="line">            [super displayLayer:layer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在项目中，并不会这些修复，毕竟是第三方库，我们可以直接替换这个类的该方法。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;YYAnimatedImageView+TB.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation YYAnimatedImageView (TB)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    Method method1 = class_getInstanceMethod([self class], NSSelectorFromString(@&quot;displayLayer:&quot;));</span><br><span class="line">    Method method2 = class_getInstanceMethod([self class], @selector(tb_displayLayer:));</span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tb_displayLayer:(CALayer *)layer&#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable(self.class, &quot;_curFrame&quot;);</span><br><span class="line">    UIImage *_curFrame = object_getIvar(self, ivar);</span><br><span class="line">    if (_curFrame) &#123;</span><br><span class="line">        layer.contents = (__bridge id)_curFrame.CGImage;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (@available(iOS 14.0, *)) &#123;</span><br><span class="line">            [super displayLayer:layer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><blockquote><p>关于真机调试</p></blockquote><p>最新Xcode 12 beta版本<code>31G</code>,而且还不稳定，如果需要使用低版本Xcode运行到iOS14的真机上可以下载<a href="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/iOS14%E9%9A%90%E7%A7%81%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%E5%8F%8A%E5%85%B6%E4%BB%96/14.0.zip" target="_blank" rel="noopener">iOS14的DeviceSupport</a>，存放的路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</span><br></pre></td></tr></table></figure><blockquote><p>关于更新iOS14系统</p></blockquote><p>关于更新iOS14 beta版的系统，我在<a href="https://jingyan.baidu.com/article/2a1383284630dd464b134f11.html" target="_blank" rel="noopener">百度经验</a>上水了篇文章，可以点击百度经验查看，当然经验水的有些粗糙，还有错别字。</p><p>也可能是好久没写了，写完后，竟然还给了0.3元的红包……</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.apple.com/videos/wwdc2020/" target="_blank" rel="noopener">WWDC2020</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2020/10676/" target="_blank" rel="noopener">WWDC2020中：建立更好的隐私信任</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2020/10652/" target="_blank" rel="noopener">WWDC2020：认识新的照片选择器</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2020/10110/" target="_blank" rel="noopener">WWDC2020-在你的应用程序中支持本地网络隐私</a></li><li><a href="https://zhuanlan.zhihu.com/p/157159226?from_voters_page=true" target="_blank" rel="noopener">iOS14新增的本地网络权限，要开给第三方App吗?</a></li><li><a href="https://mp.weixin.qq.com/s/CJML-2YUv6sqEEnI8rI0Bw" target="_blank" rel="noopener">iOS14 隐私适配及部分解决方案</a></li><li><a href="https://www.jianshu.com/p/a0b0303962bb" target="_blank" rel="noopener">iOS14 适配 先行者</a></li><li><a href="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/iOS14%E9%9A%90%E7%A7%81%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%E5%8F%8A%E5%85%B6%E4%BB%96/14.0.zip" target="_blank" rel="noopener">iOS14:DeviceSupport</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://developer.apple.com/videos/w
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于私有仓库</title>
    <link href="https://xnxy.github.io/2020/09/01/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://xnxy.github.io/2020/09/01/关于私有仓库/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2020-12-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>截止目前在我的有道云笔记里已经躺了好几篇文章没写完，目前写了一半或者刚开头的有<code>App启动优化:二进制文件重排</code>、<code>iOS逆向工程及防御</code>、<code>iOS知识点梳理</code>。</p><p>时间还是不太够用啊，而且八月份已经过去，八月份的文章还没放到博客上。除去功能增加以外，还有就是自己有些懈怠了。</p><p>除了已经写个开头的文章，还有些东西需要整理，比如Swift、Runtime、算法之类的。这些东西也不能只仅限于会用，还要知其原理并将其整理出来写成文章，避免后期的遗忘。</p><p>希望今年将这些东西都整理完吧！</p><p>而这篇文章主要整理私有仓库的创建，便于后期查阅。</p><hr><p>ps:截止这次更新，上面提到的几篇博客还没写完。</p><h1 id="私有仓库相关"><a href="#私有仓库相关" class="headerlink" title="私有仓库相关"></a>私有仓库相关</h1><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><p>一般创建私有仓库会创建到公司搭建的gitlab上，因为目前只是做演示，所以本博客的私有仓库、私有组件都创建在GitHub上，以供后期下载。</p><blockquote><p>在git中创建私有仓库</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.png" alt="私有仓库"></p><h2 id="添加私有仓库到本地"><a href="#添加私有仓库到本地" class="headerlink" title="添加私有仓库到本地"></a>添加私有仓库到本地</h2><p>在将私有仓库添加到本地之前，我们可以通过<code>pod repo list</code>指令查看本地有哪些仓库，同时可以查看本地仓库存放地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo list</span><br></pre></td></tr></table></figure><blockquote><p>查看本地仓库列表</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%931.png" alt="查看本地仓库"></p><blockquote><p>使用<code>pod repo add ZVTestPrivateSpecs https://github.com/xnxy/ZVTestPrivateSpecs.git</code>指定将私有仓库添加到本地。</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="私有仓库添加到本地"></p><blockquote><p>添加完成后可以使用<code>pod repo list</code>指令查看本地仓库列表，查看是否已经添加成功，同时也可以<code>open</code>相应目录查看。</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%932.png" alt="查看本地仓库列表"></p><h2 id="添加Podspec到私有仓库"><a href="#添加Podspec到私有仓库" class="headerlink" title="添加Podspec到私有仓库"></a>添加Podspec到私有仓库</h2><h3 id="创建私有组件"><a href="#创建私有组件" class="headerlink" title="创建私有组件"></a>创建私有组件</h3><blockquote><p>git中创建私有组件</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6.png" alt="创建私有组件"></p><p>编写组件内容，创建测试Demo等相关内容。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%88%9B%E5%BB%BADemo%E7%9B%B8%E5%85%B3.png" alt="创建Demo相关"></p><p>使用<code>pod spec creat ZVTestPod</code>指令来创建<code>podspec</code>文件，并编写相关内容。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%88%9B%E5%BB%BApodspec%E6%96%87%E4%BB%B6.png" alt="创建podspec文件"></p><p>编写完成后，将编写好的<code>podspec</code>推送到<code>git</code>，并打<code>tag</code>。</p><p>然后使用<code>pod lib lint</code>来验证<code>podspec</code>文件，如果出现下方图片中的<code>passed validation</code>则代表验证通过。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E9%AA%8C%E8%AF%81podspec%E6%96%87%E4%BB%B6.png" alt="验证podspec文件"></p><p>私有组件验证通过后，我们需要使用<code>pod repo push ZVTestPrivateSpecs ZVTestPod.podspec</code>指定将私有组件的<code>podspec</code>文件推送到私有仓库中。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E6%8E%A8%E9%80%81%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%88%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%AD.png" alt="推送私有组件到私有仓库"></p><p>推送成功后，我们可以在私有仓库中查看私有组件的位置,当然我们也可以在本地中查看</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%9C%A8git%E4%B8%AD%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="私有组件在私有仓库的位置"></p><h2 id="将私有仓库中的库集成到项目中"><a href="#将私有仓库中的库集成到项目中" class="headerlink" title="将私有仓库中的库集成到项目中"></a>将私有仓库中的库集成到项目中</h2><p>走到这一步，私有仓库、私有组件的的流程都已经介绍完了，如果想使用私有仓库中的私有组件时，直接集成项目即。跟集成开源框架类似。</p><p>其中<code>Podfile</code>的编写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/xnxy/ZVTestPrivateSpecs.git&apos;</span><br><span class="line">#source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">platform :ios, &apos;9.0&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &apos;ZVTestExample&apos; do</span><br><span class="line">    </span><br><span class="line">    pod &apos;ZVTestPod&apos;, &apos;~&gt; 0.0.1&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E9%9B%86%E6%88%90%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6.png" alt="集成私有组件到项目中"></p><h2 id="Swift和OC混编仓库"><a href="#Swift和OC混编仓库" class="headerlink" title="Swift和OC混编仓库"></a>Swift和OC混编仓库</h2><p>关于Swift和OC混编的仓库可以参考<a href="https://github.com/xnxy/ZVTestSwiftPod" target="_blank" rel="noopener">我再GitHub中创建的Demo</a></p><blockquote><p>OC调用Swift方法</p></blockquote><p>在Framework中OC调用Swift需要引入<code>#import &lt;**/**-Swift.h&gt;</code>头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ZVOCApi.m</span><br><span class="line">//  ZVTestSwiftPod</span><br><span class="line">//</span><br><span class="line">//  Created by CNTP on 2020/12/7.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ZVOCApi.h&quot;</span><br><span class="line">#import &lt;ZVTestSwiftPod/ZVTestSwiftPod-Swift.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation ZVOCApi</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;---OC调Swift---&quot;);</span><br><span class="line">    ZVSwiftApi *header = [ZVSwiftApi new];</span><br><span class="line">    [header function];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)swiftTest&#123;</span><br><span class="line">    NSLog(@&quot;---swift调OC---&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的在<code>Build Settings</code>中可以查看相应头文件配置（Xcode会自动生成）。<br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%A4%B4%E6%96%87%E4%BB%B6.jpg" alt="OC调Swift"></p><blockquote><p>Swift调用OC方法</p></blockquote><p>在Framework中Swift调用OC需要先创建<code>module.modulemap</code>文件将相应的头文件添加进去。</p><p>关于<code>modulemap</code>文件，可以参看简书的的文章<a href="https://www.jianshu.com/p/ce49d8f32f77" target="_blank" rel="noopener">《Swift 关于 module.modulemap 使用》</a>，介绍的很详细。</p><p>内容大致如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//modele.modulemap文件内容</span><br><span class="line"></span><br><span class="line">module BridgeFiles [system] &#123;</span><br><span class="line">    header &quot;ZVFileTransferHeader.h&quot;</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZVFileTransferHeader.h</code>文件中存放<code>Swift</code>需要调用的OC类。</p><p>同时需要在<code>Build Settings</code>手动添加配置，入下图所示。</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/blog/%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8CMCI%E7%A7%BB%E5%8A%A8%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5.jpg" alt="Swift调用OC配置"></p><p>添加进配置中的目录为<code>module.modulemap</code>所在的目录。</p><p>相应的在需要调用的类中引入<code>BridgeFiles</code>，然后即可调用。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ZVSwiftApi.swift</span><br><span class="line">//  ZVTestSwiftPod</span><br><span class="line">//</span><br><span class="line">//  Created by CNTP on 2020/12/7.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line">import BridgeFiles</span><br><span class="line"></span><br><span class="line">@objc public class ZVSwiftApi: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    @objc public func function() -&gt; Int &#123;</span><br><span class="line">        let obj = ZVOCApi.init()</span><br><span class="line">        obj.swiftTest()</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要添加<code>@objc</code>和<code>public</code>，或者无法调用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="noopener">private-cocoapods</a></li><li><a href="https://tech.meituan.com/2018/07/12/mci.html" target="_blank" rel="noopener">MCI:移动持续集成在大众点评的实践</a></li><li><a href="https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html" target="_blank" rel="noopener">美团iOS工程zsource 命令背后的那些事儿</a></li><li><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;截止目前在我的有道云笔记里已经躺了好几篇文章没写完，目前写了一半或者刚开头的有&lt;code&gt;A
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS微信授权登录与通用链接配置</title>
    <link href="https://xnxy.github.io/2020/07/07/iOS%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E5%8F%8A%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5%E9%85%8D%E7%BD%AE/"/>
    <id>https://xnxy.github.io/2020/07/07/iOS微信授权登录及通用链接配置/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2020-07-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>微信的<code>openSDK</code>在1.8.6版本支持了<code>Universal Links</code>方式的跳转,在使用新版本的时候需要设置<code>Universal Links</code>。</p><p><code>Universal Links</code> 是在WWDC 2005提出了iOS9的新特性之一。</p><p>具体的使用可以参考<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1" target="_blank" rel="noopener">Support Universal Links</a>和<a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content" target="_blank" rel="noopener">Allowing Apps and Websites to Link to Your Content</a>两篇文章。</p><p>这篇文章主要整理微信openSDK的对接和<code>Universal Links</code>的配置。</p><h1 id="Universal-Links配置"><a href="#Universal-Links配置" class="headerlink" title="Universal Links配置"></a><code>Universal Links</code>配置</h1><p>当你支持通用链接时，iOS用户点击一个你网站的链接，可以被无缝地重定向到你安装的应用程序，而无需通过Safari。如果你的应用程序没有被安装，点击你网站的一个链接会在Safari中打开。</p><h2 id="开发者账号配置"><a href="#开发者账号配置" class="headerlink" title="开发者账号配置"></a>开发者账号配置</h2><blockquote><p>找到相应的<code>App ID</code>,勾选<code>Associated Domains</code>选项，然后点击保存即可。</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E5%8B%BE%E9%80%89Associated%20Domains.png" alt="勾选Associated Domains选项"></p><h2 id="apple-app-site-association-文件编写"><a href="#apple-app-site-association-文件编写" class="headerlink" title="apple-app-site-association 文件编写"></a>apple-app-site-association 文件编写</h2><p>关于<code>apple-app-site-association</code>的编写，可以查看<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1" target="_blank" rel="noopener">Support Universal Links</a>中相应文档的介绍。</p><p>为通用链接添加支持非常简单，需要采取以下三个步骤：</p><ol><li>创建一个<code>apple-app-site-association</code>文件，其中包含有关应用程序可以处理的 url 的 JSON 数据。</li><li>将 <code>apple-app-site-association</code> 文件上传到 HTTPS web 服务器。 可以将文件放在<code>Web服务器</code>的根目录或子目录<code>.well-known</code>下。</li><li>开始你的应用程序来处理通用链接。</li></ol><blockquote><p>Note:<code>apple-app-site-association</code>文件是纯文本文件，没有后缀名。</p></blockquote><p>关于<code>apple-app-site-association</code>的编写的官方示例如下方所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;/videos/wwdc/2015/*&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>appID</code>中的<code>9JA89QQLNQ</code>为团队ID，<code>com.apple.wwdc</code>为BundleID。如需添加多个<code>appID</code>，如上方所示。</p><blockquote><p>关于微信对<code>Universal Links</code>配置的要求</p></blockquote><ol><li><code>Universal Links</code>必须支持https</li><li><code>Universal Links</code>配置的paths不能带query参数</li><li>微信使用<code>Universal Links</code>拉起第三方App时,会在Universal Links末尾拼接路径和参数，因此App配置的paths必须加上通配符/*</li></ol><p>微信示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">&quot;appID&quot;: &quot;8P7343TG54.com.tencent.xin.SDKSample&quot;,    </span><br><span class="line">&quot;paths&quot;: [&quot;/sdksample/*&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note:本文项目的通用链接我存放到个人的阿里云中，路径如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/apple-app-site-association</span><br></pre></td></tr></table></figure><h2 id="apple-app-site-association-文件验证"><a href="#apple-app-site-association-文件验证" class="headerlink" title="apple-app-site-association 文件验证"></a>apple-app-site-association 文件验证</h2><p>将编写好的<code>apple-app-site-association</code>文件上传到<code>Web服务器</code>的根目录或子目录<code>.well-known</code>下后，我们可以进行校验一下服务器的配置是否正确。</p><p>可以通过<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">App Search API Validation Tool</a>网页工具进行校验。</p><p>打开<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">App Search API Validation Tool</a>网页工具，输入<code>apple-app-site-association</code> 在web 服务器中的地址,类似于<code>https://***/apple-app-site-association</code>。</p><p>验证的结果可能分为三种：验证通过-未上线、验证通过-已上线和验证失败。其结果分别如下所示。</p><blockquote><p>验证通过-未上线</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%AA%8C%E8%AF%81/%E9%AA%8C%E8%AF%81%E6%88%90%E5%8A%9F-%E5%B7%B2%E4%B8%8A%E7%BA%BF.jpg" alt="验证通过-未上线"></p><blockquote><p>验证通过-已上线</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%AA%8C%E8%AF%81/%E9%AA%8C%E8%AF%81%E6%88%90%E5%8A%9F-%E6%9C%AA%E4%B8%8A%E7%BA%BF.jpg" alt="验证通过-已上线"></p><blockquote><p>验证失败</p></blockquote><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%AA%8C%E8%AF%81/%E9%AA%8C%E8%AF%81%E9%94%99%E8%AF%AF.jpg" alt="验证失败"></p><blockquote><p>Note:验证失败后，将<code>apple-app-site-association</code>存放到服务器的地址复制到浏览器中，查看<code>apple-app-site-association</code> 是否可以下载，如果可以下载查看文件内的<code>JSON</code>数据格式是否正确，如果不可以下载所以服务端配置的有问题。</p></blockquote><h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><p>如果上方的操作都已经做完，可以在工程中进行配置。</p><p>配置相对来说比较简单在 <code>TARGETS</code>-&gt;<code>Signing&amp;Capabilities</code> 中选择 <code>+ Capability</code> 然后搜索<code>Associated Domains</code>进行添加。</p><p>如图所示：</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5.png" alt="项目配置通用链接"></p><p>添加完以后，将通用链接地址填入到<code>Domains</code>中。<br><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/AssociatedDomains.jpg" alt="Associated Domains"></p><blockquote><p>Note: </p><p>如果提供的<code>apple-app-site-association</code>文件地址为<code>https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/apple-app-site-association</code></p><p>Associated Domains中需要填写(applinks：为固定格式)：<code>applinks:blog-zhouwei.oss-cn-beijing.aliyuncs.com</code></p><p>代码注册和微信开发平台中填写：<code>https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/</code></p></blockquote><p>其实配置到这里，选中证书，运行到手机。运行完后，在手机浏览器中输入<code>https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/</code> ，下滑的时候会出现从App中打开的选项。</p><p>如果将该链接复制到文本文档中，常按也会出现从App中打开的选项。</p><p>这说明<code>Universal Links</code>已经配置完成了。</p><h2 id="微信配置"><a href="#微信配置" class="headerlink" title="微信配置"></a>微信配置</h2><h3 id="配置Universal-Links"><a href="#配置Universal-Links" class="headerlink" title="配置Universal Links"></a>配置<code>Universal Links</code></h3><p>微信的通用链接配置如下方所示：</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5.png" alt="配置微信开发平台的通用链接"></p><blockquote><p>Note: 就如同上方中写道，如果通用链接地址为<code>https://**/apple-app-site-association</code>,微信的<code>Universal Links</code>需要添加<code>https://**/</code>即可。</p></blockquote><h3 id="配置URL-Types"><a href="#配置URL-Types" class="headerlink" title="配置URL Types"></a>配置<code>URL Types</code></h3><p>配置完<code>Universal Links</code>后项目中同时还需要在工程中的<code>TARGETS</code>-&gt;<code>info</code>-&gt;<code>URL Types</code>中添加<code>URL scheme</code>,其中<code>URL scheme</code>为所注册的程序id。</p><p>如下图所示：</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%85%8D%E7%BD%AEURL%20Types" alt="配置URL Types"></p><h3 id="配置LSApplicationQueriesSchemes"><a href="#配置LSApplicationQueriesSchemes" class="headerlink" title="配置LSApplicationQueriesSchemes"></a>配置<code>LSApplicationQueriesSchemes</code></h3><p>在工程的<code>info.plist</code>中添加<code>LSApplicationQueriesSchemes</code>并添加<code>weixin</code>和<code>weixinULAPI</code>,如下图所示：</p><p><img src="https://blog-zhouwei.oss-cn-beijing.aliyuncs.com/UniversalLink/%E9%85%8D%E7%BD%AEinfo.plist" alt="info.plist配置"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content" target="_blank" rel="noopener">Allowing Apps and Websites to Link to Your Content</a></li><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1" target="_blank" rel="noopener">Support Universal Links</a></li><li><a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">apple-app-site-association验证工具</a></li><li><a href="https://limitless-sierra-4673.herokuapp.com/" target="_blank" rel="noopener">Universal Link Validator</a></li><li><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html" target="_blank" rel="noopener">微信SDK-iOS接入指南</a></li><li><a href="https://www.jianshu.com/p/3a46eb4a107f" target="_blank" rel="noopener">iOS微信授权登录+Universal Link(通用链接)</a></li><li><a href="https://www.jianshu.com/p/a42e3cdf550b" target="_blank" rel="noopener">Universal Links 实现细节</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;微信的&lt;code&gt;openSDK&lt;/code&gt;在1.8.6版本支持了&lt;code&gt;Univer
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>常用命令整理</title>
    <link href="https://xnxy.github.io/2020/06/16/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>https://xnxy.github.io/2020/06/16/常用命令整理/</id>
    <published>2020-06-15T16:00:00.000Z</published>
    <updated>2020-07-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>这篇文章主要是将常用的指令整理一下，便于后期的查阅。</p><p>这篇文章会不定时更新……</p><h2 id="部署Framework到cocoapods"><a href="#部署Framework到cocoapods" class="headerlink" title="部署Framework到cocoapods"></a>部署Framework到cocoapods</h2><blockquote><p>创建podsepc文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;工程目录&gt;</span><br><span class="line"></span><br><span class="line">pod spec create MyFramework</span><br></pre></td></tr></table></figure><blockquote><p>编写podsepc文件</p></blockquote><p>可以参考<a href="https://xnxy.github.io/xnxy.github.io/2020/05/29/Podspec语法参考(翻译)/">Podspec语法</a>进行编写。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |spec|</span><br><span class="line"></span><br><span class="line">  spec.name         = &quot;ZVDynamicClipImage&quot;</span><br><span class="line">  spec.version      = &quot;0.0.1&quot;</span><br><span class="line">  spec.summary      = &quot;动态区域裁剪图片的iOS库&quot;</span><br><span class="line">  spec.homepage     = &quot;https://github.com/xnxy/ZVDynamicClipImage.git&quot;</span><br><span class="line">  spec.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">  spec.author             = &#123; &quot;拿根针尖对麦芒&quot; =&gt; &quot;1661583063@qq.com&quot; &#125;</span><br><span class="line">  spec.social_media_url   = &quot;https://xnxy.github.io&quot;</span><br><span class="line">  spec.platform     = :ios, &quot;8.0&quot;</span><br><span class="line">  spec.source       = &#123; :git =&gt; &quot;https://github.com/xnxy/ZVDynamicClipImage.git&quot;, :tag =&gt; &quot;#&#123;spec.version&#125;&quot; &#125;</span><br><span class="line">  spec.source_files  = &quot;ZVDynamicClipImage/ZVDynamicClipImage/ZVDynamicClipImage.h&quot;</span><br><span class="line"></span><br><span class="line">  spec.subspec &apos;Private&apos; do |specB|</span><br><span class="line">    specB.source_files = &quot;ZVDynamicClipImage/ZVDynamicClipImage/Private/*&quot;</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  spec.subspec &apos;Public&apos; do |specC|</span><br><span class="line">    specC.source_files = &quot;ZVDynamicClipImage/ZVDynamicClipImage/Public/*&quot;</span><br><span class="line">    specC.dependency &apos;ZVDynamicClipImage/Private&apos;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>验证<code>podspec</code>格式是否正确</p></blockquote><p>使用<code>pod lib lint</code>验证<code>podspec</code>文件格式是否正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint MyFramework.podspec --verbose --allow-warnings</span><br></pre></td></tr></table></figure><blockquote><p>提交<code>podspec</code>文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push MyFramework.podspec</span><br></pre></td></tr></table></figure><h2 id="管理trunk账号"><a href="#管理trunk账号" class="headerlink" title="管理trunk账号"></a>管理trunk账号</h2><blockquote><p>注册trunk账号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 你的邮箱 &apos;用户名&apos; --description=&apos;描述内容&apos; （邮箱参数是必须的，用户名和--description参数可省略）</span><br></pre></td></tr></table></figure><blockquote><p>查看注册信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure><blockquote><p>提交podspec文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push 文件名.podspec</span><br></pre></td></tr></table></figure><blockquote><p>将公共库的podspec文件部署到自己的私有库中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push REPO 文件名.podspec # REPO 私有索引库名</span><br></pre></td></tr></table></figure><blockquote><p>添加他人共同维护某库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk add-owner 公共库名 已注册trunk的邮箱地址</span><br></pre></td></tr></table></figure><blockquote><p>移除某个维护人员</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk remove-owner 公共库名 已注册trunk的邮箱地址</span><br></pre></td></tr></table></figure><blockquote><p>移除已发的某个版本对应的工程信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk delete 工程名 版本号</span><br></pre></td></tr></table></figure><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><blockquote><p>查看pod版本及环境信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod env</span><br></pre></td></tr></table></figure><blockquote><p>引用某个私有库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line">source &apos;https://gitee.com/xnxyonly1/ZVPrivate.git&apos;</span><br><span class="line">platform :ios, &apos;9.0&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &apos;ZVPrivateDemo&apos; do</span><br><span class="line"></span><br><span class="line"> pod &apos;ZVPrivate&apos;, :git =&gt; &apos;https://gitee.com/xnxyonly1/ZVPrivate.git&apos;, :tag =&gt; &apos;0.0.1&apos;</span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>更新本地缓存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod cache clean --all</span><br><span class="line">rm -rf ~/Library/Caches/CocoaPods</span><br><span class="line">pod repo update</span><br></pre></td></tr></table></figure><blockquote><p>Mac软件无法安装时，可以对其重签名</p></blockquote><p>有的软件安装到电脑上时会提示“……将对您的电脑造成伤害，您应该将它移到废纸篓”的提示。</p><p>可以对其进行重签名，先判断是否安装命令行工具<code>xcode-select --version</code></p><p>如果未安装，使用<code>xcode-select --install</code>指令进行安装，安装成功后执行下方指令对其进行重签名。</p><p>签名成功后重新打开即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -f -s - --deep /Applications/软件名.app</span><br></pre></td></tr></table></figure><blockquote><p>安装与卸载cocoapods</p></blockquote><p>VPN如果自动模式不行的话，切换都全局模式，选择美国的节点。</p><p>安装cocoapods：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>指定安装cocoapods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 1.6.1</span><br></pre></td></tr></table></figure><p>查看当前cocoapods版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod --version</span><br><span class="line">或</span><br><span class="line">gem list</span><br></pre></td></tr></table></figure><p>移除程序包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gem uninstall cocoapods</span><br><span class="line">或指定某版本：</span><br><span class="line">sudo gem uninstall cocoapods -v 1.9.1</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.cocoapods.org/CocoaPods-Trunk/" target="_blank" rel="noopener">CocoaPods Trunk</a></li><li><a href="https://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="noopener">Podspec Syntax Reference v1.9.0</a></li><li><a href="https://guides.cocoapods.org/syntax/podfile.html" target="_blank" rel="noopener">Podfile Syntax Reference</a></li><li><a href="https://guides.cocoapods.org/terminal/commands.html" target="_blank" rel="noopener">Command-line Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;这篇文章主要是将常用的指令整理一下，便于后期的查阅。&lt;/p&gt;
&lt;p&gt;这篇文章会不定时更新……
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="cocoapods" scheme="https://xnxy.github.io/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>如何编译iOS版OpenCV动态库</title>
    <link href="https://xnxy.github.io/2020/05/11/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91iOS%E7%89%88OpenCV%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://xnxy.github.io/2020/05/11/如何编译iOS版OpenCV动态库/</id>
    <published>2020-05-11T09:49:58.000Z</published>
    <updated>2020-05-11T09:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>将<code>OpenCV</code>的编译动态库单独拎出来写这篇博客，主要是因为根据官方的教程编译出来的动态库将可执行程序内部的<code>install Name</code>写死了，导致动态库无法链接到，报<code>dyld: Library not loaded:</code>错误。</p><p>在<code>GitHub</code>上<code>OpenCV</code>库的<code>issues</code>上也有人提，但并没有得到解决。</p><p>而它打包用的是<code>cmake</code>,自己也不想去修改他的<code>Python脚本</code>和<code>cmake文件</code>,于是使用了<code>install_name_tool</code>工具修改<code>OpenCV</code>二进制文件中的链接路径，完美地解决了该问题。</p><p>于是将其记录下来，以便后期查阅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用脚本直接打包OpenCV动态库，添加到项目中会报下方错误：</span><br><span class="line"></span><br><span class="line">dyld: Library not loaded: /Users/cntp/Documents/opencv-4.1.0/platforms/ios/ios/build/build-iphonesimulator/lib/Release/opencv2.framework/opencv2</span><br><span class="line"></span><br><span class="line">  Referenced from: /private/var/containers/Bundle/Application/UUID/MyApp.app/Frameworks/MyApp.framework/MyApp</span><br><span class="line">  Reason: image not found</span><br><span class="line"></span><br><span class="line">使用otool工具查看，会发现二进制文件中将链接路径写成固定路径：</span><br><span class="line"></span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework % otool -L opencv2</span><br><span class="line">opencv2:</span><br><span class="line">/Users/cntp/Documents/opencv-4.1.0/platforms/ios/ios/build/build-iphonesimulator/lib/Release/opencv2.framework/opencv2 (compatibility version 4.1.0, current version 4.1.0)</span><br></pre></td></tr></table></figure><h2 id="关于Opencv"><a href="#关于Opencv" class="headerlink" title="关于Opencv"></a>关于<code>Opencv</code></h2><p><a href="https://zh.wikipedia.org/wiki/OpenCV" target="_blank" rel="noopener">OpenCV</a>的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。</p><blockquote><p>主要模块分为以下几种：</p></blockquote><ul><li>core：简洁核心模块，基本函数，基本数据结构；</li><li>imgproc：图像处理模块，线性和非线性图像滤波，几何图像转换，颜色空间转换，直方图等；</li><li>video：视频分析模块，运动估计，背景消除，物体跟踪算法；</li><li>calib3d：基本多视角几何算法，单体和立体相机的标定，对象姿势估计，双目立体匹配算法和元素的三维重建；</li><li>features2d：包含了显著特征检测算法，描述算子和算子匹配算法；</li><li>objdetect：物体检测和一些预定义的物体的检测（如人脸，眼睛，杯子，人，汽车等）；</li><li>ml：多种机器学习算法，如K均值，支持向量机和神经网络；</li><li>highgui：简单易用接口，有视频捕捉，图像和视频编码功能，简单UI接口，iOS的是其中一个子集；</li><li>gpu：GPU加速算法，iOS不可用；</li><li>ocl：OpenCL通用算法，iOS不可用；</li><li>其它，辅助、算法等。</li></ul><blockquote><p>OpenCV可用于解决如下领域问题：</p></blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/擴增實境" target="_blank" rel="noopener">增强现实</a></li><li><a href="https://zh.wikipedia.org/wiki/人脸识别" target="_blank" rel="noopener">人脸识别</a></li><li><a href="https://zh.wikipedia.org/wiki/手势识别" target="_blank" rel="noopener">手势识别</a></li><li><a href="https://zh.wikipedia.org/wiki/人机交互" target="_blank" rel="noopener">人机交互</a></li><li>动作识别</li><li>运动跟踪</li><li><a href="https://zh.wikipedia.org/wiki/物体识别" target="_blank" rel="noopener">物体识别</a></li><li><a href="https://zh.wikipedia.org/wiki/图像分割" target="_blank" rel="noopener">图像分割</a></li><li><a href="https://zh.wikipedia.org/wiki/机器人" target="_blank" rel="noopener">机器人</a></li></ul><h2 id="关于Cmake"><a href="#关于Cmake" class="headerlink" title="关于Cmake"></a>关于<code>Cmake</code></h2><p><code>OpenCV</code>使用<code>Cmake</code>工具进行编译的，所以在打包Framework之前我们也需要了解<code>Cmake</code>。</p><p><code>CMake</code>是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。具体内容可以查看<a href="https://baike.baidu.com/item/cmake/7138032?fr=aladdin" target="_blank" rel="noopener">百度百科关于Cmake的介绍</a></p><p>同时也可以查看<a href="https://cmake.org" target="_blank" rel="noopener">CMake官网</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMake是旨在构建，测试和打包软件的开源，跨平台工具系列。</span><br><span class="line">CMake用于使用简单平台和独立于编译器的配置文件来控制软件编译过程，并生成可在您选择的编译器环境中使用的本机makefile和工作区。</span><br><span class="line">CMake工具套件是由Kitware创建的，旨在满足ITK和VTK等开源项目对功能强大的跨平台构建环境的需求。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">CMake is an open-source, cross-platform family of tools designed to build, test and package software. </span><br><span class="line">CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice.</span><br><span class="line">The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</span><br></pre></td></tr></table></figure><h3 id="第一步：查看是否安装Cmake"><a href="#第一步：查看是否安装Cmake" class="headerlink" title="第一步：查看是否安装Cmake"></a>第一步：查看是否安装<code>Cmake</code></h3><p>如果想在Mac上编译OpenCV，需要检测Mac中是否安装过<code>Cmake</code>。</p><p>对于如何查看，我们可以直接在终端输入<code>cmake --version</code>,如果有相应版本会出现下方内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro ~ % Cmake --version</span><br><span class="line">cmake version 3.17.1</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>如果出现<code>-bash: cmake: command not found</code>则代表电脑中并没有安装<code>Cmake</code>。</p><p>如果没有安装<code>Cmake</code>可以通过<code>Homebrew</code>进行安装，具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br></pre></td></tr></table></figure><p>其中<code>Homebrew</code>是Mac OS平台下的软件包管理工具，大家应该都不陌生，具体的使用可以查看<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew官网</a>。</p><p>安装完成后即可编译OpenCV动态库</p><h3 id="第二步：编译OpenCV动态库"><a href="#第二步：编译OpenCV动态库" class="headerlink" title="第二步：编译OpenCV动态库"></a>第二步：编译<code>OpenCV</code>动态库</h3><p>下载相应版本的<code>OpenCV</code>，<code>cd</code>到<code>~/platforms/ios</code>目录，我们可以看到其打包的脚本<code>build_framework.py</code>，语言是<code>Python</code>并不是常用的<code>Shell</code>脚本,不过语言很简单。</p><p>如果项目中需要静态库，可以直接到<a href="https://opencv.org/" target="_blank" rel="noopener">opencv官网</a>下载，或者直接使用<code>python build_framework.py ios</code>，其中<code>ios</code>为编译文件的路径，最后会在<code>ios</code>下看到<code>opencv2.framework</code>。</p><p>如果需要编译动态库需要在后面添加<code>--dynamic</code>，或者到<code>python</code>脚本中将<code>parser.add_argument(&#39;--dynamic&#39;, default=False, action=&#39;store_true&#39;, help=&#39;build dynamic framework (default is &quot;False&quot; - builds static framework)&#39;)</code>中的<code>default</code>改为<code>true</code>。</p><p>打包动态库的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/cntp/Documents/opencv-4.1.0/platforms/ios </span><br><span class="line"></span><br><span class="line">python build_framework.py ios --dynamic</span><br></pre></td></tr></table></figure><p>编译时间会比较长，结束后会在<code>/Users/cntp/Documents/opencv-4.1.0/platforms/ios/ios</code>目录下得到相应的<code>opencv2.framework</code>。</p><p>ps:不用吐槽<code>ios</code>不是<code>iOS</code>,它那边文档就是这样写的，也就这样用了。</p><h3 id="第三步：修改OpenCV二进制文件中的链接地址"><a href="#第三步：修改OpenCV二进制文件中的链接地址" class="headerlink" title="第三步：修改OpenCV二进制文件中的链接地址"></a>第三步：修改<code>OpenCV</code>二进制文件中的链接地址</h3><p>理论上到这一步就可以了，直接将<code>opencv2.framework</code>添加到外面工程中，修改<code>Embed</code>为<code>Embed&amp;Sign</code>就可以。</p><p>但当在运行时加载<code>opencv.framework</code>时，它会直接报错，由终端的打印日志可以看出app链接的路径为打包存放的默认路径，也就是<code>/Users/cntp/Documents/opencv-4.1.0/platforms/ios/ios</code>。</p><p>我们可以使用<code>otool</code>工具进行查看,命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework % otool -L opencv2</span><br><span class="line">opencv2:</span><br><span class="line">/Users/cntp/Documents/opencv-4.1.0/platforms/ios/ios/build/build-iphonesimulator/lib/Release/opencv2.framework/opencv2 (compatibility version 4.1.0, current version 4.1.0)</span><br><span class="line">/System/Library/Frameworks/Accelerate.framework/Accelerate (compatibility version 1.0.0, current version 4.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics (compatibility version 64.0.0, current version 1251.12.0)</span><br><span class="line">/System/Library/Frameworks/QuartzCore.framework/QuartzCore (compatibility version 1.2.0, current version 1.11.0)</span><br><span class="line">/System/Library/Frameworks/AssetsLibrary.framework/AssetsLibrary (compatibility version 1.0.0, current version 1.0.0)</span><br><span class="line">/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)</span><br><span class="line">/System/Library/Frameworks/AVFoundation.framework/AVFoundation (compatibility version 1.0.0, current version 2.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreImage.framework/CoreImage (compatibility version 1.0.0, current version 5.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreVideo.framework/CoreVideo (compatibility version 1.2.0, current version 1.5.0)</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1570.15.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br><span class="line">/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1570.15.0)</span><br><span class="line">/usr/lib/libc++abi.dylib (compatibility version 1.0.0, current version 400.17.0)</span><br></pre></td></tr></table></figure><p>我们可以看到链接<code>opencv2.framework/opencv2</code>的路径(install Name)是写死的。</p><p>而正确的动态库的链接路径(install Name)应该是<code>@rpath/opencv2.framework/opencv2</code>。</p><p>知道这一点后我们使用<code>install_name_tool</code>工具修改它的链接路径即可，我们可以将它写死的链接路径(install Name)修改成<code>@rpath/opencv2.framework/opencv2</code>，具体操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework % install_name_tool h</span><br><span class="line">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/install_name_tool [-change old new] ... [-rpath old new] ... [-add_rpath new] ... [-delete_rpath old] ... [-id name] input</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework % install_name_tool -id @rpath/opencv2.framework/opencv2 opencv2</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework % otool -L opencv2</span><br><span class="line">opencv2:</span><br><span class="line">@rpath/opencv2.framework/opencv2 (compatibility version 4.1.0, current version 4.1.0)</span><br><span class="line">/System/Library/Frameworks/Accelerate.framework/Accelerate (compatibility version 1.0.0, current version 4.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics (compatibility version 64.0.0, current version 1251.12.0)</span><br><span class="line">/System/Library/Frameworks/QuartzCore.framework/QuartzCore (compatibility version 1.2.0, current version 1.11.0)</span><br><span class="line">/System/Library/Frameworks/AssetsLibrary.framework/AssetsLibrary (compatibility version 1.0.0, current version 1.0.0)</span><br><span class="line">/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)</span><br><span class="line">/System/Library/Frameworks/AVFoundation.framework/AVFoundation (compatibility version 1.0.0, current version 2.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreImage.framework/CoreImage (compatibility version 1.0.0, current version 5.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)</span><br><span class="line">/System/Library/Frameworks/CoreVideo.framework/CoreVideo (compatibility version 1.2.0, current version 1.5.0)</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1570.15.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br><span class="line">/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1570.15.0)</span><br><span class="line">/usr/lib/libc++abi.dylib (compatibility version 1.0.0, current version 400.17.0)</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro opencv2.framework %</span><br></pre></td></tr></table></figure><p>使用<code>install_name_tool h</code>查看所有指令，根据提示使用<code>install_name_tool -id @rpath/opencv2.framework/opencv2 opencv2</code>修改其链接路径(install Name)。</p><p>可以再使用<code>otool</code>工具验证一下,发现没有问题，然后再将其添加到项目中，因为是动态库，修改<code>Embed</code>为<code>Embed&amp;Sign</code>运行、使用同样没有问题。</p><p>至此问题完美解决。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><h2 id="关于-rpath、-loader-path、-executable-path"><a href="#关于-rpath、-loader-path、-executable-path" class="headerlink" title="关于@rpath、@loader_path、@executable_path"></a>关于@rpath、@loader_path、@executable_path</h2><p>在<code>Framework</code>工程的<code>TARGETS</code>-&gt;<code>Build Settings</code>中的<code>Linking</code>可以看到<code>Dynamic Library Install Name</code>、<code>Dynamic Library Install Name Base</code>、<code>Runpath Search Paths</code>等配置，根据其名称可以大致了解其含义。</p><p>这里先梳理下几个单词的概念。</p><h3 id="install-Name"><a href="#install-Name" class="headerlink" title="install Name"></a>install Name</h3><p><code>install Name</code>可以理解为安装名称，本质上是一个相对路径，主要是告诉链接器(linker synthesized)在运行时从哪调用需要的库。</p><p>就比如刚刚编译的动态库<code>opencv2.framework</code>，在编译的时候会被拷贝到应用程序（**.app）下的<code>Frameworks</code>目录下，其二进制文件的绝对路径地址大致为<code>~/-.app/Frameworks/opencv2.framework/opencv2</code>，其中<code>install Name</code>就是<code>@rpath/opencv2.framework/opencv2</code>。</p><p>当动态链接器需要<code>opencv2.framework</code>的时候，它就会从应用程序中根据<code>install Name</code>找到<code>opencv2.framework</code>。</p><h3 id="rpath"><a href="#rpath" class="headerlink" title="@rpath"></a>@rpath</h3><p>在维基百科中有关于<a href="https://en.wikipedia.org/wiki/Rpath" target="_blank" rel="noopener">rpath</a>的介绍:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In computing, rpath designates the run-time search path hard-coded in an executable file or library. Dynamic linking loaders use the rpath to find required libraries.</span><br><span class="line"></span><br><span class="line">Specifically, it encodes a path to shared libraries into the header of an executable (or another shared library). This RPATH header value (so named in the Executable and Linkable Format header standards) may either override or supplement the system default dynamic linking search paths.</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在计算中 rpath指定在可执行文件或库中硬编码的运行时 搜索路径。动态链接加载程序时使用rpath查找所需的库。</span><br><span class="line"></span><br><span class="line">具体来说，它将共享库的路径编码为可执行文件（或另一个共享库）的标头。此RPATH标头值（在“ 可执行文件和链接格式”标头标准中如此命名）可以替代或补充系统默认的动态链接搜索路径。</span><br></pre></td></tr></table></figure><p>其解释已经十分详细了，我们可以理解为<code>@rpath</code>就是一个相对路径。</p><p>其中<code>@rpath/opencv2.framework/opencv2</code>就相当于我们项目下动态库所在的位置<code>~/**.app/Frameworks/opencv2.framework/opencv2</code>。</p><h3 id="loader-path"><a href="#loader-path" class="headerlink" title="@loader_path"></a>@loader_path</h3><p><code>@loader_path</code>是<code>Framework</code>工程中<code>TARGETS -&gt; Build Settings -&gt; Linking -&gt; Runpath Search Paths</code>的一项配置,字面上的意思是加载路径。</p><p>其实也就是<code>Framework</code>加载的路径，比如<code>app</code>下的动态库<code>opencv2.framework</code>其<code>@loader_path</code>则相当于<code>~/**.app/Frameworks/opencv2.framework</code>。</p><h3 id="executable-path"><a href="#executable-path" class="headerlink" title="@executable_path"></a>@executable_path</h3><p><code>@executable_path</code>是<code>Framework</code>工程中<code>TARGETS -&gt; Build Settings -&gt; Linking -&gt; Runpath Search Paths</code>的一项配置,字面上的意思是可执行文件路径。</p><p>跟<code>@loader_path</code>不同的是<code>@executable_path</code>代表的是可执行文件(mach-o)的路径。还以<code>app</code>下加载动态库<code>opencv2.framework</code>为例，其<code>@executable_path</code>则相当于<code>~/**.app/Frameworks/opencv2.framework/opencv2</code></p><p>ps：写完<code>关于@rpath、@loader_path、@executable_path</code>本来还想将程序如何链接动态库、静态库写一下，最后还是决定单独拎出来写。</p><p>同时准备将动、静态库相互依赖；编译打包动、静态库；等注意事项整理下。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">opencv源码</a></li><li><a href="https://opencv.org/" target="_blank" rel="noopener">opencv官网</a></li><li><a href="https://zh.wikipedia.org/wiki/OpenCV" target="_blank" rel="noopener">OpenCV-维基百科</a></li><li><a href="https://docs.opencv.org/2.4/doc/tutorials/introduction/ios_install/ios_install.html#ios-installation" target="_blank" rel="noopener">Installation in iOS</a></li><li><a href="https://baike.baidu.com/item/cmake/7138032?fr=aladdin" target="_blank" rel="noopener">关于Cmake</a></li><li><a href="https://cmake.org" target="_blank" rel="noopener">CMake官网</a></li><li><a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew官网</a></li><li><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fdebug-prefix-map" target="_blank" rel="noopener">Clang命令行参数参考</a></li><li><a href="https://en.wikipedia.org/wiki/Rpath" target="_blank" rel="noopener">rpath</a></li><li><a href="https://matthew-brett.github.io/docosx/mac_runtime_link.html" target="_blank" rel="noopener">Runtime linking on Mac</a></li><li><a href="https://www.jianshu.com/p/cd614e080078" target="_blank" rel="noopener">Xcode中的链接路径问题</a></li><li><a href="https://developer.apple.com/documentation/" target="_blank" rel="noopener">Apple Developer Documentation</a></li><li><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1" target="_blank" rel="noopener">Dynamic Library Programming Topics</a></li><li><a href="https://developer.apple.com/library/archive/navigation/" target="_blank" rel="noopener">Documentation Archive</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;将&lt;code&gt;OpenCV&lt;/code&gt;的编译动态库单独拎出来写这篇博客，主要是因为根据官方
      
    
    </summary>
    
      <category term="记录" scheme="https://xnxy.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Framework" scheme="https://xnxy.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何判断设备是否为iPhone X,iOS获取设备型号的方法。</title>
    <link href="https://xnxy.github.io/2020/05/08/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E4%B8%BAiPhone%20X,iOS%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E5%9E%8B%E5%8F%B7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://xnxy.github.io/2020/05/08/如何判断设备是否为iPhone X,iOS获取设备型号的方法/</id>
    <published>2020-05-08T02:49:17.000Z</published>
    <updated>2020-05-08T02:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为本公司的项目一直是竖屏，所以一开始的思路是根据屏幕上方的状态栏的高度进行判断，但最后考虑到手机开启WiFi共享、或者有地图类软件打开时上方会有蓝条，根据导航栏判断是否为刘海屏就不准确了。</p><p>所以说起来最准确的就是根据设备的型号进行判断，因为苹果不同设备的型号不同，而我们可以获取到设备的型号，所以根据型号进行判断是最准确的。</p><p>但这样判断还是有缺点的，就是如果苹果出了新的手机时，我们需要重新将刘海屏的设备型号添加进去。</p><p>还有一点就是在模拟器上，获取的设备型号是i386和x86_64，所以在模拟器中我们可以根据屏幕宽高或者屏幕下方安全区域进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (BOOL)isIphoneX&#123;</span><br><span class="line">    struct utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];</span><br><span class="line">    if ([platform isEqualToString:@&quot;i386&quot;] || [platform isEqualToString:@&quot;x86_64&quot;]) &#123;</span><br><span class="line">        UIWindow *keyWindow = [[[UIApplication sharedApplication] delegate] window];</span><br><span class="line">        // 获取底部安全区域高度，iPhone X 竖屏下为 34.0，横屏下为 21.0，其他类型设备都为 0</span><br><span class="line">        BOOL haveSafeInset;</span><br><span class="line">        if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">            CGFloat bottomSafeInset = keyWindow.safeAreaInsets.bottom;</span><br><span class="line">            haveSafeInset = (bottomSafeInset == 34.0f || bottomSafeInset == 21.0f);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            haveSafeInset = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        return haveSafeInset;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL isIPhoneX = [platform isEqualToString:@&quot;iPhone10,3&quot;] || [platform isEqualToString:@&quot;iPhone10,6&quot;] || [platform isEqualToString:@&quot;iPhone11,8&quot;] || [platform isEqualToString:@&quot;iPhone11,2&quot;] || [platform isEqualToString:@&quot;iPhone11,6&quot;] || [platform isEqualToString:@&quot;iPhone11,4&quot;];</span><br><span class="line">    return isIPhoneX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于设备的型号，我有大致写一下，不过具体的还是建议从<a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">苹果设备类型说明</a>里面进行查看，然后当需要更新相应设备的时候可以直接在自己代码中添加。</p><p><img src="http://upload-images.jianshu.io/upload_images/1388397-f3be3dce72ee1e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".m中的代码"></p><hr><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">苹果设备类型说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为本公司的项目一直是竖屏，所以一开始的思路是根据屏幕上方的状态栏的高度进行判断，但最后考虑到手机开启WiFi共享、或者有地图类软件打开时上方会有蓝条，根据导航栏判断是否为刘海屏就不准确了。&lt;/p&gt;
&lt;p&gt;所以说起来最准确的就是根据设备的型号进行判断，因为苹果不同设备的型号
      
    
    </summary>
    
      <category term="随笔" scheme="https://xnxy.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本的使用及整理</title>
    <link href="https://xnxy.github.io/2020/04/29/shell%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%95%B4%E7%90%86/"/>
    <id>https://xnxy.github.io/2020/04/29/shell脚本的使用及整理/</id>
    <published>2020-04-29T08:04:39.000Z</published>
    <updated>2020-04-29T08:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>这篇文章应该算对自己之前使用Jenkins、Shell脚本打包项目的总结。</p><p>毕竟之前很多东西要么存到项目中，要么存在笔记中，并没有进行整理。</p><h1 id="关于shell"><a href="#关于shell" class="headerlink" title="关于shell"></a>关于shell</h1><p>关于<code>shell</code>脚本的介绍，可以查看<a href="https://baike.baidu.com/item/shell/99702" target="_blank" rel="noopener">百度百科</a>中的介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">任何代码最终需要被‘翻译’成二进制的形式才能在计算机中执行。</span><br><span class="line"></span><br><span class="line">有的编程语言，如C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都编程成二进制形式(可执行文件),用户拿到最终生成的可执行文件，看不到源码。</span><br><span class="line"></span><br><span class="line">这个过程叫做编译（Compile），这样的编程语言叫做[编译型语言]，完成编译过程的软件叫做编译器[Compiler]。</span><br><span class="line"></span><br><span class="line">而有的编程语言，如Shell、JavaScript、Python、PHP等，需要一边执行一边翻译，不会生成任何可执行文件，用户拿到源代码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</span><br><span class="line"></span><br><span class="line">这个过程叫做解释，这样的编程语言叫做[解释型语言]或者[脚本语言]（Script），完成解释过程的软件叫做解释器。</span><br><span class="line"></span><br><span class="line">编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。</span><br><span class="line"></span><br><span class="line">脚本语言的优点是使用灵活、部署容易、跨平台性好、非常适合Web开发以及小工具的制作。</span><br><span class="line"></span><br><span class="line">Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</span><br></pre></td></tr></table></figure><h2 id="shell历史"><a href="#shell历史" class="headerlink" title="shell历史"></a>shell历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于历史原因，UNIX系统上有很多种Shell：</span><br><span class="line"></span><br><span class="line">1.sh（Bourne Shell）：由Steve Bourne开发，各种UNIX系统都配有sh。</span><br><span class="line"></span><br><span class="line">2.csh（C Shell）：由Bill Joy开发，随BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能：作业控制，命令历史，命令行编辑。</span><br><span class="line"></span><br><span class="line">3.ksh（Korn Shell）：由David Korn开发，向后兼容sh的功能，并且添加了csh引入的新功能，是目前很多UNIX系统标准配置的Shell，在这些系统上/bin/sh往往是指向/bin/ksh的符号链接。</span><br><span class="line"></span><br><span class="line">4.tcsh（TENEX C Shell）：是csh的增强版本，引入了命令补全等功能，在FreeBSD、Mac OS X等系统上替代了csh。</span><br><span class="line"></span><br><span class="line">5.bash（Bourne Again Shell）：由GNU开发的Shell，主要目标是与POSIX标准保持一致，同时兼顾对sh的兼容，bash从csh和ksh借鉴了很多功能，是各种Linux发行版标准配置的Shell，在Linux系统上/bin/sh往往是指向/bin/bash的符号链接。虽然如此，bash和sh还是有很多不同的，一方面，bash扩展了一些命令和参数，另一方面，bash并不完全和sh兼容，有些行为并不一致，所以bash需要模拟sh的行为：当我们通过sh这个程序名启动bash时，bash可以假装自己是sh，不认扩展的命令，并且行为与sh保持一致。</span><br></pre></td></tr></table></figure><h1 id="术语名词"><a href="#术语名词" class="headerlink" title="术语名词"></a>术语名词</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- IDC--（Internet Data Center)互联网数据中心，主要服务包括整机租用、服务器托管、机柜租用、机房租用、专线接入和网络管理服务等。广义上的IDC业务，实际上就是数据中心所提供的一切服务。客户租用数据中心的服务器和带宽，并利用数据中心的技术力量，来实现自己对软、硬件的要求，搭建自己的互联网平台，享用数据中心所提供的一系列服务。</span><br><span class="line"></span><br><span class="line">- ISP--(Internet Service Provider)互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。</span><br><span class="line"></span><br><span class="line">- ICP--(Internet Content Provider)互联网内容提供商，向广大用户综合提供互联网信息业务和增值业务的电信运营商。 根据中华人民共和国国务院令第292号《互联网信息服务管理办法》规定，国家对提供互联网信息服务的ICP实行许可证制度。从而，ICP证成为网站经营的许可证，经营性网站必须办理ICP证，否则就属于非法经营。因此，办理ICP证是企业网站合法经营的需要.</span><br><span class="line"></span><br><span class="line">- CDN--(Content Delivery Network)内容分发网络,依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</span><br><span class="line"></span><br><span class="line">- LVS--(Linux Virtual Server)的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。</span><br><span class="line"></span><br><span class="line">- CGI--(Common Gateway Interface)通用网关接口。CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。</span><br><span class="line"></span><br><span class="line">- GSLB--(Global Server Load Balance，全局负载均衡）作为 CDN 系统架构中最核心的部分，负责流量调度.基于DNS的GSLB 绝大部分使用负载均衡技术的应用都通过域名来访问目的主机，在用户发出任何应用连接请求时，首先必须通过DNS请求获得服务器的IP地址，基于DNS的GSLB正是在返回DNS解析结果的过程中进行智能决策，给用户返回一个最佳的服务IP。用户应用流程与没有GSLB时未发生任何变化。这也是市场上主流的GSLB技术。</span><br><span class="line"></span><br><span class="line">- BOSS--(Business &amp; Operation Support System，BOSS)是业务运营支撑系统。通常所说的BOSS分为四个部分：计费及结算系统、营业与账务系统、客户服务系统和决策支持系统。BOSS从业务层面来看就是一个框架，来承载业务系统、CRM系统、计费系统。实现统一框架中的纵向、横向管理。该系统最早由电信部门的计费系统发展演变而来，基本功能包括客户资料管理、产品管理、用户订购管理、计费、出帐、结算等，负责登记客户资料、管理用户订购服务的提供、实时的根据不同产品、套餐的资费标准计算业务（手机、固定电话用户通话时、点播收视、宽带流量与时间等）的消费金额，准实时及定期计算用户帐单，实时或定期结算用户各种消费费用。</span><br></pre></td></tr></table></figure><h1 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h1><h3 id="获取SDK或IPA的版本号"><a href="#获取SDK或IPA的版本号" class="headerlink" title="获取SDK或IPA的版本号"></a>获取SDK或IPA的版本号</h3><p>使用<code>shell</code>脚本获取SDK或IPA的版本号，跟我们在代码中获取IPA的版本号一样，都是解析Info.plist中的<code>CFBundleShortVersionString</code>。</p><p>所以在这里就可以使用Mac自带的专门解析plist的小工具<code>PlistBuddy</code>来获取项目的版本号。</p><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#获取Inof.plist中的版本号</span><br><span class="line">buildVersion=$(/usr/libexec/PlistBuddy -c &quot;print:CFBundleShortVersionString&quot; $&#123;projectPath&#125;../tpocr/tpocr/Info.plist)</span><br></pre></td></tr></table></figure><p>同理我们可以将打包IPA所需的<code>scheme</code>、<code>configuration</code>……等信息存放到<code>config.plist</code>中，使用<code>PlistBuddy</code>直接读取，我们需要修改相应参数的时候可以直接修改<code>config.plist</code>，避免直接修改脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#工程项目路径</span><br><span class="line">projectPath=&quot;$(pwd)&quot;</span><br><span class="line">#build配置文件</span><br><span class="line">buildConfigFile=&quot;$&#123;projectPath&#125;/Packaging/config.plist&quot;</span><br><span class="line">#打包的target名称</span><br><span class="line">buildSchemeName=$(/usr/libexec/PlistBuddy -c &quot;print:build:scheme&quot; $&#123;buildConfigFile&#125;)</span><br><span class="line">#build configuration</span><br><span class="line">buildConfiguration=$(/usr/libexec/PlistBuddy -c &quot;print:build:configuration&quot; $&#123;buildConfigFile&#125;)</span><br><span class="line">#export options plist</span><br><span class="line">exportOptionsPlist=&quot;$&#123;projectPath&#125;/Packaging/$(/usr/libexec/PlistBuddy -c &quot;print:build:exportPlist&quot; $&#123;buildConfigFile&#125;).plist&quot;</span><br><span class="line">#用于签名的企业开发者名称</span><br><span class="line">enterpriseDistributionSignName=$(/usr/libexec/PlistBuddy -c &quot;print:resign:enterpriseName&quot; $&#123;buildConfigFile&#125;)</span><br><span class="line">#企业打包provision证书</span><br><span class="line">enterpriseProvisionFile=&quot;$&#123;projectPath&#125;/Packaging/$(/usr/libexec/PlistBuddy -c &quot;print:resign:enterpriseProvision&quot; $&#123;buildConfigFile&#125;).mobileprovision&quot;</span><br><span class="line">#Jenkins job</span><br><span class="line">jenkinsJob=$(/usr/libexec/PlistBuddy -c &quot;print:deliver:jenkinsJob&quot; $&#123;buildConfigFile&#125;)</span><br><span class="line">#fir api token</span><br><span class="line">firAPIToken=$(/usr/libexec/PlistBuddy -c &quot;print:deliver:fir&quot; $&#123;buildConfigFile&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用Xcodebuild指令对项目进行打包"><a href="#使用Xcodebuild指令对项目进行打包" class="headerlink" title="使用Xcodebuild指令对项目进行打包"></a>使用Xcodebuild指令对项目进行打包</h3><p>xcodebuild是命令行工具包(Command Line Tools)中的一项，是一个轻量型的、可以与Xcode分开的、在Mac上单独下载的命令行工具包。</p><p>在<code>/usr/bin</code>目录下，我们可以在终端使用<code>open /usr/bin</code>查找该工具。而在<code>usr/bin</code>目录下还有很多命令工具，比如：git、make、xcrun等。</p><p>在xcode9后build不指定任何签名信息，具体编译命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#编译IPA</span><br><span class="line">xcodebuild -workspace $&#123;workspace&#125; -scheme &quot;$buildSchemeName&quot; -configuration &quot;$buildConfiguration&quot; -sdk iphoneos clean archive -archivePath $&#123;archiveFilePath&#125; | xcpretty</span><br><span class="line"></span><br><span class="line">#导出ipa文件</span><br><span class="line">xcodebuild -allowProvisioningUpdates -exportArchive -archivePath $&#123;archiveFilePath&#125; -exportPath $&#123;ipaDir&#125; -exportOptionsPlist $&#123;exportOptionsPlist&#125; | xcpretty</span><br></pre></td></tr></table></figure><p>导出的文件中除了导出ipa包以外，还有dSYM文件。</p><p>dSYM是符号表文件，每次打包我们需要保存好，如果后面项目出现问题，我们可以使用dSYM分析其崩溃信息。</p><h3 id="使用xcodebuild指令打包Framework"><a href="#使用xcodebuild指令打包Framework" class="headerlink" title="使用xcodebuild指令打包Framework"></a>使用xcodebuild指令打包Framework</h3><p>我们手动打包Framework的时候，是先将每个指令集进行打包，然后使用<code>lipo -create</code>将其合并，使用命令打包也是这个逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">### Build simulator platform. (i386, x86_64)</span><br><span class="line">echo &quot;========== Build Simulator Platform ==========&quot;</span><br><span class="line">echo &quot;===== Build Simulator Platform: i386 =====&quot;</span><br><span class="line">xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk iphonesimulator BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; CONFIGURATION_BUILD_DIR=&quot;$&#123;IPHONE_SIMULATOR_BUILD_DIR&#125;/i386&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; ARCHS=&apos;i386&apos; VALID_ARCHS=&apos;i386&apos; -UseModernBuildSystem=NO $ACTION</span><br><span class="line"></span><br><span class="line">echo &quot;===== Build Simulator Platform: x86_64 =====&quot;</span><br><span class="line">xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk iphonesimulator BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; CONFIGURATION_BUILD_DIR=&quot;$&#123;IPHONE_SIMULATOR_BUILD_DIR&#125;/x86_64&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; ARCHS=&apos;x86_64&apos; VALID_ARCHS=&apos;x86_64&apos; -UseModernBuildSystem=NO $ACTION</span><br><span class="line"></span><br><span class="line">### Build device platform. (armv7, arm64)</span><br><span class="line">echo &quot;========== Build Device Platform ==========&quot;</span><br><span class="line">echo &quot;===== Build Device Platform: armv7 =====&quot;</span><br><span class="line">xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk iphoneos BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot;  CONFIGURATION_BUILD_DIR=&quot;$&#123;IPHONE_DEVICE_BUILD_DIR&#125;/armv7&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; ARCHS=&apos;armv7&apos; VALID_ARCHS=&apos;armv7&apos; -UseModernBuildSystem=NO $ACTION</span><br><span class="line"></span><br><span class="line">echo &quot;===== Build Device Platform: arm64 =====&quot;</span><br><span class="line">xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk iphoneos BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; CONFIGURATION_BUILD_DIR=&quot;$&#123;IPHONE_DEVICE_BUILD_DIR&#125;/arm64&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; ARCHS=&apos;arm64&apos;  VALID_ARCHS=&apos;arm64&apos; -UseModernBuildSystem=NO $ACTION</span><br><span class="line"></span><br><span class="line">### Build device platform. (arm64, armv7)</span><br><span class="line">echo &quot;========== Build Universal Platform ==========&quot;</span><br><span class="line">## Copy the framework structure to the universal folder (clean it first).</span><br><span class="line">rm -rf &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;&quot;</span><br><span class="line">mkdir -p &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;&quot;</span><br><span class="line">## Copy the last product files of xcodebuild command.</span><br><span class="line">cp -R &quot;$&#123;IPHONE_DEVICE_BUILD_DIR&#125;/arm64/$&#123;PRODUCT_NAME&#125;.framework&quot; &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/$&#123;PRODUCT_NAME&#125;.framework&quot;</span><br><span class="line">echo &quot;Smash them together to combine all architectures.&quot;</span><br><span class="line">lipo -create  &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/i386/$&#123;PRODUCT_NAME&#125;.framework/$&#123;PRODUCT_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/x86_64/$&#123;PRODUCT_NAME&#125;.framework/$&#123;PRODUCT_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/armv7/$&#123;PRODUCT_NAME&#125;.framework/$&#123;PRODUCT_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/arm64/$&#123;PRODUCT_NAME&#125;.framework/$&#123;PRODUCT_NAME&#125;&quot; -output &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/$&#123;PRODUCT_NAME&#125;.framework/$&#123;PRODUCT_NAME&#125;&quot;</span><br><span class="line">echo &quot;Copy Framework Code Signature&quot;</span><br><span class="line">cp -R &quot;$&#123;IPHONE_SIMULATOR_BUILD_DIR&#125;/x86_64/$&#123;PRODUCT_NAME&#125;.framework/_CodeSignature&quot; &quot;$&#123;UNIVERSAL_OUTPUTFOLDER&#125;/$&#123;PRODUCT_NAME&#125;.framework/&quot;</span><br></pre></td></tr></table></figure><h3 id="关于xcpretty"><a href="#关于xcpretty" class="headerlink" title="关于xcpretty"></a>关于xcpretty</h3><p>将<code>xcpretty</code>拎出来单独说，是因为刚复工回来，更新了电脑的<code>ruby</code>然后导致了打包脚本不能使用，才注意到它。</p><p><code>xcpretty</code>是一个用ruby实现的小工具，可以使用<code>gem install xcpretty</code>，作用是美化<code>xcodebuild</code>冗长的日志输入。</p><p>如需使用<code>xcpretty</code>对日志进行美化只需要在<code>xcodebuild</code>命令后面加入<code>| xcpretty</code>即可。</p><p>类似于下方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace $&#123;workspace&#125; -scheme &quot;$buildSchemeName&quot; -configuration &quot;$buildConfiguration&quot; | xcpretty</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>shell脚本的for循环结构和我们的<code>OC</code>中<code>for in</code>遍历有些类似。<br>例如下方脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#获取所有jar包并上传</span><br><span class="line">for workitem in `ls $&#123;updatePath&#125;/`; do</span><br><span class="line">workspaceDir=$&#123;updatePath&#125;&quot;/&quot;$workitem</span><br><span class="line">echo &quot;\n---jar包目录：\n$&#123;workspaceDir&#125;---\n&quot;</span><br><span class="line">java -jar /Users/apple/Desktop/build/UpdateService/jenkins-file-service.jar $&#123;workspaceDir&#125; 1 /home/verifaceops/jenkins-file/taiping_src/</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>该脚本其主要功能是遍历<code>${updatePath}</code>目录下的的文件，然后将所有文件上传到公司内网的文件服务器中。</p><p>这很类似于我们了解的<code>for in</code>遍历了。</p><p>for循环的一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><code>shll</code>中的<code>while</code>循环也跟<code>OC</code>和<code>C</code>的用法和写法类似，比如下方一个验证密码是否正确（当然在现实中并不会用到）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#脚本内容：</span><br><span class="line">echo &quot;请输入打包密码:&quot;</span><br><span class="line">read TRY</span><br><span class="line">while [ &quot;$TRY&quot; != &quot;tplife&quot; ]; do</span><br><span class="line">  echo &quot;抱歉，密码错误！\n请重新输入：&quot;</span><br><span class="line">  read TRY</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#终端输出：</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro Python_Project % sh build.sh</span><br><span class="line">请输入打包密码:</span><br><span class="line">123</span><br><span class="line">抱歉，密码错误！</span><br><span class="line">请重新输入：</span><br><span class="line">tplife</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro Python_Project %</span><br></pre></td></tr></table></figure><h3 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h3><p><code>shell</code>的<code>if</code>语法跟<code>OC</code>类似，但感觉所有语言并没有<code>OC</code>写着优雅。</p><p>if语句语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>if else 语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>if else-if else 语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-eq           //等于</span><br><span class="line">-ne           //不等于</span><br><span class="line">-gt            //大于 （greater ）</span><br><span class="line">-lt            //小于  （less）</span><br><span class="line">-ge            //大于等于</span><br><span class="line">-le            //小于等于</span><br><span class="line"></span><br><span class="line">命令的逻辑关系：</span><br><span class="line">在linux 中 命令执行状态：0 为真，其他为假</span><br><span class="line">逻辑与： &amp;&amp;</span><br><span class="line">第一个条件为假时，第二条件不用再判断，最终结果已经有；</span><br><span class="line">第一个条件为真时，第二条件必须得判断；</span><br><span class="line">逻辑或： ||</span><br><span class="line">逻辑非： ！</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#xcode9后build不指定任何签名信息</span><br><span class="line">xcodebuild -workspace $&#123;workspace&#125; -scheme &quot;$buildSchemeName&quot; -configuration &quot;$buildConfiguration&quot; -sdk iphoneos clean archive -archivePath $&#123;archiveFilePath&#125; | xcpretty</span><br><span class="line"></span><br><span class="line">EXCODE=$?</span><br><span class="line">if [ &quot;$EXCODE&quot; == &quot;0&quot; ]; then</span><br><span class="line">echo &quot;Build, Archive ----&gt; O.K&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;***********************编译失败********************************&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">echo &quot;***********************结束build archive app文件***********************&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#将打包的apk和IPA包上传到蒲公英</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#  update.sh</span><br><span class="line">#  </span><br><span class="line">#</span><br><span class="line">#  Created by CNTP on 2020/04/14.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">export LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line"></span><br><span class="line">updateAndroidPath=&quot;/Users/apple/Desktop/build/OCR/Android&quot;</span><br><span class="line">updateiOSPath=&quot;/Users/apple/Desktop/build/OCR/iOS&quot;</span><br><span class="line">userKey=&quot;**&quot;</span><br><span class="line">apiKey=&quot;**&quot;</span><br><span class="line"></span><br><span class="line"># ----- 上传Android apk -----</span><br><span class="line">echo &quot;\n\n----- 上传Android apk -----\n\n&quot;</span><br><span class="line"></span><br><span class="line">for workitem in `ls $&#123;updateAndroidPath&#125;`; do</span><br><span class="line">filePath=$&#123;updateAndroidPath&#125;&quot;/&quot;$workitem</span><br><span class="line">if [[ &quot;$&#123;filePath##*.&#125;&quot;x = &quot;apk&quot;x ]]; then</span><br><span class="line">echo &quot;----文件----$&#123;filePath&#125;---&quot;</span><br><span class="line">curl -F &quot;file=@$filePath&quot; \</span><br><span class="line">-F &quot;uKey=$&#123;userKey&#125;&quot; \</span><br><span class="line">-F &quot;_api_key=$&#123;apiKey&#125;&quot; \</span><br><span class="line">https://www.pgyer.com/apiv1/app/upload</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#----- 上传iOS IPA -----</span><br><span class="line">echo &quot;\n\n----- 上传iOS IPA -----\n\n&quot;</span><br><span class="line">cd $&#123;updateiOSPath&#125;</span><br><span class="line">unzip ipa-1.0.zip</span><br><span class="line">for workitem in `ls $&#123;updateiOSPath&#125;/ipa-1.0/1.0`; do</span><br><span class="line">filePath=$&#123;updateiOSPath&#125;&quot;/ipa-1.0/1.0/&quot;$workitem</span><br><span class="line">if [[ &quot;$&#123;filePath##*.&#125;&quot;x = &quot;ipa&quot;x ]]; then</span><br><span class="line">echo &quot;----文件----$&#123;filePath&#125;---&quot;</span><br><span class="line">curl -F &quot;file=@$filePath&quot; \</span><br><span class="line">-F &quot;uKey=$&#123;userKey&#125;&quot; \</span><br><span class="line">-F &quot;_api_key=$&#123;apiKey&#125;&quot; \</span><br><span class="line">https://www.pgyer.com/apiv1/app/upload</span><br><span class="line">rm -rf $&#123;updateiOSPath&#125;/ipa-1.0</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="Android打包"><a href="#Android打包" class="headerlink" title="Android打包"></a>Android打包</h3><p>Android打包是调用工程根目录下的gradlew来完成打包。</p><p>cd到相应工程目录，然后执行<code>gradlew clean</code>清理缓存，然后再执行<code>gradlew assembleRelease</code>进行打包。</p><p>具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean</span><br><span class="line">gradlew assembleRelease</span><br></pre></td></tr></table></figure><p><code>gradlew clean</code>是清理工程目录下的<code>build</code>文件夹。<br><code>gradlew assembleRelease</code>是编译并打<code>Release</code>包，同理<code>gradlew assembleDebug</code>是编译是打<code>Debug</code>包。</p><p>我们也可以使用<code>gradlew build</code>命令将<code>debug</code>、<code>release</code>环境的包都打出来。</p><h3 id="服务端打包"><a href="#服务端打包" class="headerlink" title="服务端打包"></a>服务端打包</h3><p>服务端那边是使用<code>Maven</code>进行自动化打包。</p><p>全程也只有下方一个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p>首先使用<code>Maven</code>需要在<code>Mac</code>系统上安装和配置<code>Maven</code>环境。</p><p>具体配置可以参考<a href="https://blog.csdn.net/winstonlau/article/details/95605557" target="_blank" rel="noopener">Mac系统下载、安装和配置Maven环境</a>这篇文章。</p><p>因还有其他逻辑，所以将所有逻辑存放在<code>build.sh</code>文件中。但在调用时发现，会报配置出错。</p><p>所以需要在<code>Jenkins</code>配置的<code>Execute shell</code>中添加<code>#!/bin/bash -ilex</code>。</p><p>其中<code>build.sh</code>为编译jar包的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash -ilex</span><br><span class="line">cd /Users/apple/Desktop/build/taiping_src</span><br><span class="line">sh build.sh</span><br></pre></td></tr></table></figure><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4" target="_blank" rel="noopener">shell-维基百科</a></li><li><a href="https://baike.baidu.com/item/shell/99702" target="_blank" rel="noopener">shell-百度百科</a></li><li><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">shell教程-菜鸟</a></li><li><a href="http://c.biancheng.net/shell/base/" target="_blank" rel="noopener">Shell基础</a></li><li><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></li><li><a href="https://www.jianshu.com/p/7248276d3bb5" target="_blank" rel="noopener">Gradle与Maven的区别</a></li><li><a href="https://blog.csdn.net/winstonlau/article/details/95605557" target="_blank" rel="noopener">Mac系统下载、安装和配置Maven环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;这篇文章应该算对自己之前使用Jenkins、Shell脚本打包项目的总结。&lt;/p&gt;
&lt;p&gt;毕
      
    
    </summary>
    
      <category term="整理" scheme="https://xnxy.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="shell" scheme="https://xnxy.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>自动打包脚本报ruby找不到错误</title>
    <link href="https://xnxy.github.io/2020/03/31/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC%E6%8A%A5ruby%E6%89%BE%E4%B8%8D%E5%88%B0%E9%94%99%E8%AF%AF/"/>
    <id>https://xnxy.github.io/2020/03/31/自动打包脚本报ruby找不到错误/</id>
    <published>2020-03-31T07:43:27.000Z</published>
    <updated>2020-03-31T07:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近更新了CocoaPods，同时也更新了ruby，但在使用Jenkins自动打包的时候，发现脚本报错。在查询时发现网上很多错误信息，于是决定整理一下，方便以后查询。</p><blockquote><p>编译报错内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro tpocrdemo % sh Packaging/AutoPackaging.sh</span><br><span class="line">***********************开始build archive app文件***********************</span><br><span class="line">当前目录路径--------&gt;/Users/cntp/Desktop/tpaiface-ios/ocr-191103/tp/tpaiface/dev/iphone/tpocr-v1.0.191101/tpocrdemo</span><br><span class="line">Packaging/AutoPackaging.sh: /usr/local/bin/xcpretty: /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/bin/ruby: bad interpreter: No such file or directory</span><br><span class="line">***********************编译失败********************************</span><br></pre></td></tr></table></figure><p>从报错信息中可以看出在使用<code>xcpretty</code>时使用的相应ruby版本未找到。</p><p>于是使用<code>open /System/Library/Frameworks/Ruby.framework/Versions</code> 打开相应目录发现目录中下级目录为<code>/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby</code>跟预期版本不符。</p><p>那就切换一下即可。</p><blockquote><p>查看<code>ruby</code>当前版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro ~ % rvm current</span><br><span class="line">ruby-2.5.1</span><br><span class="line">cntp@TPL-0000-161520deMacBook-Pro ~ % ruby --version</span><br><span class="line">ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin18]</span><br></pre></td></tr></table></figure><p>在使用<code>ruby --version</code>和<code>rvm current</code>指令查看版本时发现<code>ruby</code>的版本为<code>2.5.1</code>，而电脑中的那个目录为<code>2.6</code>，看来需要更新<code>ruby</code>，不过理论到排查到这里，只要切换下<code>ruby</code>的版本就可以了。</p><blockquote><p>切换<code>ruby</code>版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cntp@TPL-0000-161520deMacBook-Pro ~ % rvm --default use 2.5.1</span><br><span class="line">Using /Users/cntp/.rvm/gems/ruby-2.5.1</span><br></pre></td></tr></table></figure><p>因为目录电脑安装的<code>ruby</code>的版本为<code>2.5.1</code>所以使用<code>rvm --default use 2.5.1</code>指令将Mac上的<code>ruby</code>的版本切换到<code>2.5.1</code>。</p><blockquote><p>运行脚本验证</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*************************自动打包结束**************************</span><br><span class="line">README.mdipa-1.0tpocr-ios-v1.0.191101.zip</span><br><span class="line">docipa-1.0.ziptpocr接口设计说明.md</span><br><span class="line">************************* done! 😎 **************************</span><br><span class="line">打包完成，本次共节约 4 分钟</span><br></pre></td></tr></table></figure><p>运行脚本，发现脚本已经不会报错，说明问题已经解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近更新了CocoaPods，同时也更新了ruby，但在使用Jenkins自动打包的时候，发现脚本报错。在查询时发现网上很多错误信息，于是决定整理一下，方便以后查询。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译报错内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="记录" scheme="https://xnxy.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS动态库</title>
    <link href="https://xnxy.github.io/2020/02/28/%E5%85%B3%E4%BA%8EiOS%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://xnxy.github.io/2020/02/28/关于iOS动态库/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2020-02-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h1 id="动态库概述"><a href="#动态库概述" class="headerlink" title="动态库概述"></a>动态库概述</h1><p>决定应用程序性能的两个重要因素是它们启动时间和它们的内存占用量。减少应用程序可执行文件的大小，并在启动后最大程度地减少其内存使用量，使该应用程序启动熟读更快，并在启动后使用较少的内存。使用动态库而不是静态库可减少应用程序的可执行文件大小。他们还允许应用程序仅在需要时而不是在启动时才延迟具有特殊功能的库加载。此功能进一步有助于缩短启动时间和有效使用内存。</p><p>本文介绍了动态库，并说明了如何使用动态库而不是静态库来减少应用程序文件大小和初始内存占用。本文还概述了应用程序在运行时用于动态库加载程序兼容性功能。</p><h2 id="什么是动态库？"><a href="#什么是动态库？" class="headerlink" title="什么是动态库？"></a>什么是动态库？</h2><p>应用程序的大多数功能都是在可执行代码库中实现的。使用静态连接器将应用程序与库链接后，该应用程序使用的代码将复制到生成的可执行文件中。<code>A 静态链接</code>收集编译源代码，称为目标代码和库代码成一个可执行文件在运行时加载到存储器中的全部。成为应用程序可执行文件一部分的库称为静态库。<code>静态库</code>是目标文件的集合或归档。</p><blockquote><p>Note：静态库也称为静态档案库和静态链接的共享库。</p></blockquote><p>启动应用程序是,该应用程序的代码（包括与之链接的静态库的代码）被加载到应用程序的地址空间中。将许多静态库链接到应用程序中会生成大型应用程序可执行文件。<strong>图1</strong>显示静态库中实现的功能的应用程序的内存使用情况。具有大型可执行文件的应用程序会遇到启动速度慢和内存占用大的问题。此外，更新静态库后，其客户端应用程序也不会从对其进行的改进中收益。要访问改进的功能，应用程序的开发人员必须将应用程序的目标文件与库的新版本链接。应用程序用户将不得不用最新版本替换其应用程序副本。因此，要使用程序始终具有静态库提供的最新功能，就需要开发人员和最终用户进行破坏性的工作。</p><p><strong>图1 使用静态库的应用</strong></p><p><img src="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/art/address_space1_2x.png" alt="图1 使用静态库的应用"></p><p>更好的方法是让应用在启动时或运行时在实际需要时将代码加载到其地址空间中。提供这种灵活性的库的类型称为<code>动态库</code>。动态库不是静态链接到客户端应用程序中的。它们不会成为可执行文件的一部分。相反，可以在启动应用程序或运行时将动态库加载（并链接到应用程序）。</p><blockquote><p>Note: 动态库也称为动态共享库，共享对象或动态链接库。</p></blockquote><p>图2显示了如何将某些功能实现为动态库而不是静态库，以减少启动后应用程序使用的内存。</p><p><strong>图2 使用动态库的应用程序</strong></p><p><img src="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/art/address_space2_2x.png" alt="图2 使用动态库的应用程序"></p><p>使用动态库，程序可以从对其自动使用的库的改进中受益，因为他们与库的链接是动态的，而不是静态的。也就是说，可以在不要求应用程序开发人员重新编译应用程序的情况下改进和扩展客户端应用程序的功能。为OS X 编写的应用程序受益于此功能，因为OS X 中的所有系统库都是动态库。这就是使用Carbon或Cocoa技术的应用程序如何从OS X的改进中受益的方法。</p><p>动态库提供的另一个好吃是，它们可以在加载时初始化，并且在客户端应用正常终止时可以执行清理任务。静态库没有此功能。有关详细信息，请参见<code>模块初始化器和终结器</code>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><h2 id="Podfile-配置"><a href="#Podfile-配置" class="headerlink" title="Podfile 配置"></a>Podfile 配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line">source &apos;http://***/iOS/yryc-specs.git&apos;</span><br><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">workspace &apos;MyDemo.xcworkspace&apos;</span><br><span class="line"></span><br><span class="line">target &apos;MyDemo&apos; do</span><br><span class="line">project &apos;MyDemo.xcodeproj&apos;</span><br><span class="line"></span><br><span class="line"> pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.1.1&apos;</span><br><span class="line"> pod &apos;ZLPhotoBrowser&apos;</span><br><span class="line"> pod &apos;MySDK&apos;, :git =&gt; &apos;http://***/iOS/MySDK.git&apos;, :branch =&gt; &apos;master&apos;</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &apos;MySDK&apos; do</span><br><span class="line">project &apos;../MySDK/MySDK.xcodeproj&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.1.1&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p> 查看SDK和IPA二进制文件包含指令集</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd 到SDK 或 IPA Mach-O二进制文件目录</span><br><span class="line"></span><br><span class="line">lipo -info MySDK</span><br></pre></td></tr></table></figure><blockquote><p>查看SDK和IPA二进制文件包含的动态库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 到SDK 或 IPA Mach-O二进制文件目录</span><br><span class="line"></span><br><span class="line">otool -L MySDK</span><br></pre></td></tr></table></figure><blockquote></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2018/07/12/mci.html" target="_blank" rel="noopener">MCI：移动持续集成在大众点评的实践</a></li><li><a href="https://juejin.im/post/5a620cf5f265da3e36415764" target="_blank" rel="noopener">蜂鸟商家版 iOS 组件化 / 模块化实践总结</a></li><li><a href="https://developer.apple.com/documentation" target="_blank" rel="noopener">Developer Documentation</a></li><li><a href="https://clang.llvm.org/docs/Modules.html#introduction" target="_blank" rel="noopener">LLVM</a></li><li><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1" target="_blank" rel="noopener">Dynamic Library Programming Topics</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;h1 id=&quot;动态库概述&quot;&gt;&lt;a href=&quot;#动态库概述&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="翻译" scheme="https://xnxy.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Framework" scheme="https://xnxy.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发适配iOS11&amp;iPhone X 、Xcode9遇到的坑</title>
    <link href="https://xnxy.github.io/2019/09/09/2017-10-12/"/>
    <id>https://xnxy.github.io/2019/09/09/2017-10-12/</id>
    <published>2019-09-09T11:53:52.000Z</published>
    <updated>2019-09-09T11:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-tableView向下偏移，部分UIScrollView布局出现混乱。"><a href="#1-tableView向下偏移，部分UIScrollView布局出现混乱。" class="headerlink" title="1.tableView向下偏移，部分UIScrollView布局出现混乱。"></a>1.<code>tableView</code>向下偏移，部分<code>UIScrollView</code>布局出现混乱。</h2><blockquote><p>   原因：<br>   因<code>iOS11</code>弃用了<code>automaticallyAdjustsScrollViewInsets</code> 使用了<code>contentInsetAdjustmentBehavior</code>代替。</p></blockquote><blockquote><p>解决方法如下,其中<code>@available(iOS 11.0, *)</code>表示在<code>iOS11</code>版本以上可用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然我们可以定义个宏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define  KAdjustsScrollViewInsets_NO(scrollView,vc)\</span><br><span class="line">_Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">_Pragma(&quot;clang diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;) \</span><br><span class="line">if (@available(iOS 11.0,*))  &#123;\</span><br><span class="line">scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;\</span><br><span class="line">&#125; else &#123;\</span><br><span class="line">self.automaticallyAdjustsScrollViewInsets = NO;\</span><br><span class="line">&#125;\</span><br><span class="line">_Pragma(&quot;clang diagnostic pop&quot;) \</span><br></pre></td></tr></table></figure><h2 id="2-TableView的区头、区尾、cell高度变大。"><a href="#2-TableView的区头、区尾、cell高度变大。" class="headerlink" title="2.TableView的区头、区尾、cell高度变大。"></a>2.<code>TableView</code>的区头、区尾、<code>cell</code>高度变大。</h2><blockquote><p>原因：因为<code>TaBleView</code>的 <code>estimatedRowHeight</code>、<code>estimatedSectionHeaderHeight</code>、<code>estimatedSectionFooterHeight</code>三个高度由默认的<code>0</code>变成了<code>UITableViewAutomaticDimension</code>，导致了高度计算不对。</p></blockquote><blockquote><p>解决方法：</p><p>在相应界面，将三个属性都设为<code>0</code>；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">_tableView.estimatedRowHeight = 0;</span><br><span class="line">_tableView.estimatedSectionHeaderHeight = 0;</span><br><span class="line">_tableView.estimatedSectionFooterHeight = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了方便我们也可以定义宏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define TableViewCloseTheEstimate(tableView)\</span><br><span class="line">if (@available(iOS 11.0, *)) &#123;\</span><br><span class="line">tableView.estimatedRowHeight = 0;\</span><br><span class="line">tableView.estimatedSectionHeaderHeight = 0;\</span><br><span class="line">tableView.estimatedSectionFooterHeight = 0;\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然我们如果想全局都将这三个属性设为<code>0</code>，也可以在<code>AppDelegate.m</code> 中进行全局设置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">[UITableView appearance].estimatedRowHeight = 0;</span><br><span class="line">[UITableView appearance].estimatedSectionHeaderHeight = 0;</span><br><span class="line">[UITableView appearance].estimatedSectionFooterHeight = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-部分Block警告"><a href="#3-部分Block警告" class="headerlink" title="3.部分Block警告"></a>3.部分<code>Block</code>警告</h2><p><img src="/xnxy.github.io/2019/09/09/2017-10-12/block.png" alt="image"></p><blockquote><p>例如：</p></blockquote><p><img src="/xnxy.github.io/2019/09/09/2017-10-12/block-1.png" alt="image"></p><blockquote><p> 原因：定义未带参数的<code>Block</code>时，<code>Xcode9</code>中会报上面错误。</p></blockquote><blockquote><p>解决方法：</p></blockquote><ul><li>参数位置为 <code>void</code> 。</li><li>部分第三方也有此种警告。你不可能一个个去修改修改，所以我们需要在<code>Build Setting</code>——&gt; <code>Other Warning Flags</code> 中添加：<code>-Wno-strict-prototypes</code>,然后再<code>Clean</code>、<code>Build</code>。这种方法只是屏蔽警告……</li></ul><p><img src="/xnxy.github.io/2019/09/09/2017-10-12/block-2.png" alt="image"></p><h2 id="4-ReactiveCocoa-Unknown-warning-group-39-Wreceiver-is-weak-39-ignored-警告"><a href="#4-ReactiveCocoa-Unknown-warning-group-39-Wreceiver-is-weak-39-ignored-警告" class="headerlink" title="4.ReactiveCocoa Unknown warning group &#39;-Wreceiver-is-weak&#39;,ignored 警告"></a>4.<code>ReactiveCocoa Unknown warning group &#39;-Wreceiver-is-weak&#39;,ignored</code> 警告</h2><blockquote><p>原因：之前的<code>Xcode</code>中如果消息的接收者是一个<code>weak</code>对象时，<code>clang</code>编译器会报 <code>receiver-is-weak</code>警告，所以在<code>ReactiveCocoa</code>中添加了下方的<code>push</code>&amp;<code>pop</code>以消除警告。而在<code>Xcode9</code>中<code>clang</code>已经把这个警告给移除，所以再添加下方<code>push</code>&amp;<code>pop</code>就会有警告。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \</span><br><span class="line">(&#123; \</span><br><span class="line">_Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">_Pragma(&quot;clang diagnostic ignored \&quot;-Wreceiver-is-weak\&quot;&quot;) \</span><br><span class="line">__weak id target_ = (TARGET); \</span><br><span class="line">[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \</span><br><span class="line">_Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>解决方法：</p><p>将<code>pod &#39;ReactiveCocoa&#39;, &#39;2.5&#39;</code>换成下方。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;ReactiveCocoa&apos;, :git =&gt; &apos;https://github.com/zhao0/ReactiveCocoa.git&apos;, :tag =&gt; &apos;2.5.2&apos;</span><br></pre></td></tr></table></figure><h2 id="5-友盟社会化组件在Xcode9上无法编译。"><a href="#5-友盟社会化组件在Xcode9上无法编译。" class="headerlink" title="5. 友盟社会化组件在Xcode9上无法编译。"></a>5. 友盟社会化组件在<code>Xcode9</code>上无法编译。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pods/UMengSocialCOM/Umeng_SDK_Social_iOS_ARM64_5.2.1/UMSocial_Sdk_5.2.1/SocialSDKXib/UMSCommentDetailController.xib: warning: Internationalization is not available when compiling for targets before iOS 6.0</span><br></pre></td></tr></table></figure><blockquote><p>原因：之前引用的<code>pod &#39;UMengSocialCOM&#39;, &#39;~&gt; 5.2.1&#39;</code>，此版本友盟已不再维护，替换成<code>UMengUShare</code>。<br>因项目中只使用了<code>微信</code>、<code>微博</code>、<code>QQ</code>的登录和分享，所以<code>Podfile</code>文件中将 <code>pod &#39;UMengSocialCOM&#39;, &#39;~&gt; 5.2.1&#39;</code> 替换为👇</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#友盟社会化组件</span><br><span class="line">pod &apos;UMengUShare/Network&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/Core&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/UI&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/Plugin&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/Social/WeChat&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/Social/QQ&apos;, &apos;~&gt; 6.4.5&apos;</span><br><span class="line">pod &apos;UMengUShare/Social/Sina&apos;, &apos;~&gt; 6.4.5&apos;</span><br></pre></td></tr></table></figure><blockquote><p>同时为了后期的维护，我们对所需要用到的接口进行了二次封装；</p></blockquote><h2 id="6-iPhone-X-中-TabBar下方多了一条透明区域。"><a href="#6-iPhone-X-中-TabBar下方多了一条透明区域。" class="headerlink" title="6.iPhone X 中 TabBar下方多了一条透明区域。"></a>6.<code>iPhone X</code> 中 <code>TabBar</code>下方多了一条透明区域。</h2><blockquote><p>原因： <code>iPhone X</code> 的底部是预留给系统功能的一个区域 <code>Home Indicator</code>, 高度<code>34pt</code>。如果使用的系统的<code>TabBar</code>,那么<code>Home Indicator</code>就会延展相应的<code>barTintColor</code>，而我们使用是自定义的。</p></blockquote><blockquote><p>解决方法：<br>我们在所以<code>ViewContrller</code>继承的基类<code>BaseViewController</code>中添加了<code>self.edgesForExtendedLayout = UIRectEdgeNone</code>;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">self.edgesForExtendedLayout = UIRectEdgeNone;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完后，布局可能有所变化。<br>就比如我们的一些布局为：<code>make.top.equalTo(self.view.top).offset(kNavigationAndStatusBarHeight)</code>;  需要改为：<code>make.top.equalTo(self.view.top)</code>；</p></blockquote><h2 id="7-iPhone-X中状态栏高度变高"><a href="#7-iPhone-X中状态栏高度变高" class="headerlink" title="7.iPhone X中状态栏高度变高"></a>7.<code>iPhone X</code>中状态栏高度变高</h2><blockquote><p>原因: <code>iPhone X</code>全面屏，增加了<code>刘海儿</code>，高度从之前的<code>20pt</code>变成了<code>44pt</code>。<br>所以我们定义宏的时候就不能直接写死。</p></blockquote><blockquote><p>解决方法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define kStatusBarHeight ([[UIApplication sharedApplication] statusBarFrame].size.height)</span><br></pre></td></tr></table></figure><blockquote><p>同时补上定义的其他宏</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define kStatusBarHeight ([[UIApplication sharedApplication] statusBarFrame].size.height)</span><br><span class="line">#define kNavigationBarHeight 44.f</span><br><span class="line">#define kNavigationAndStatusBarHeight (kStatusBarHeight + 44.f)</span><br><span class="line">#define kTabBarHeight 49.f</span><br><span class="line">#define KiPhoneXTabBarHeight (34.f + 49.f)</span><br><span class="line">#define KHomeIndicatorHeight 34.f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define kSCREEN_WIDTH          ([UIScreen mainScreen].bounds.size.width)</span><br><span class="line">#define kSCREEN_HEIGHT         ([UIScreen mainScreen].bounds.size.height)</span><br><span class="line"></span><br><span class="line">// iPhone5 or iPhone5s</span><br><span class="line">#define  iPhone5_5s_SE     (kSCREEN_WIDTH == 320.f &amp;&amp; kSCREEN_HEIGHT == 568.f)</span><br><span class="line"></span><br><span class="line">//iPhone6 or iPhone6s or iPhone7 or iPhone8</span><br><span class="line">#define  iPhone6_6s_7_8     (kSCREEN_WIDTH == 375.f &amp;&amp; kSCREEN_HEIGHT == 667.f)</span><br><span class="line"></span><br><span class="line">//iPhone6Plus or iPhone6sPlus or iPhone7Plus or iPhone8Plus</span><br><span class="line">#define  iPhone6Plus_6sPlus_7Plus_8Plus (kSCREEN_WIDTH == 414.f &amp;&amp; kSCREEN_HEIGHT == 736.f)</span><br><span class="line"></span><br><span class="line">//iPhone X</span><br><span class="line">#define iPhoneX     (kSCREEN_WIDTH == 375.f &amp;&amp; kSCREEN_HEIGHT == 812.f)</span><br></pre></td></tr></table></figure><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/themes/" target="_blank" rel="noopener">iOS11人机交互指南</a></li><li><a href="http://www.jianshu.com/p/7b15f92fc73e" target="_blank" rel="noopener">iOS11人机交互指南-01 iPhone X概览</a></li><li><a href="http://www.jianshu.com/p/c355cc4b12c2" target="_blank" rel="noopener">适配iOS11&amp;iPhone X 的一些坑</a></li><li><a href="https://www.apple.com/cn/iphone/compare/" target="_blank" rel="noopener">iPhone机型比较</a></li><li><a href="http://www.jianshu.com/p/26fc39135c34" target="_blank" rel="noopener">简书App适配iOS11</a></li><li><a href="http://www.jianshu.com/p/9376eca870b8" target="_blank" rel="noopener">iOS开发 设配iOS11</a></li><li><a href="https://tech.meituan.com/iPhoneX刘海打理指北.html" target="_blank" rel="noopener">iPhone X 刘海打理指北</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484087&idx=1&sn=c7465eab852fb95a043b20826b40ad91&chksm=e9d0c955dea740439b3fa1c839745a99281800dc494509d6898b60f4806035447beb6327f094&scene=38#wechat_redirect" target="_blank" rel="noopener">iPhone X 刘海儿打理指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-tableView向下偏移，部分UIScrollView布局出现混乱。&quot;&gt;&lt;a href=&quot;#1-tableView向下偏移，部分UIScrollView布局出现混乱。&quot; class=&quot;headerlink&quot; title=&quot;1.tableView向下偏移，部分
      
    
    </summary>
    
      <category term="开发" scheme="https://xnxy.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
      <category term="iPhone X" scheme="https://xnxy.github.io/tags/iPhone-X/"/>
    
  </entry>
  
  <entry>
    <title>iOS客户端UI界面设计的原则及规范</title>
    <link href="https://xnxy.github.io/2019/09/09/2017-10-20/"/>
    <id>https://xnxy.github.io/2019/09/09/2017-10-20/</id>
    <published>2019-09-09T11:47:24.000Z</published>
    <updated>2019-09-09T11:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>为方便产品、UI设计师、开发人员在产品细节上达成共识，减少沟通成本，提升开发效率，特整理iOS设备的App设计规范。此规范适用于iOS平台所有App及大多数iOS端网页设计。</p><h3 id="1-标准单位"><a href="#1-标准单位" class="headerlink" title="1.标准单位"></a>1.标准单位</h3><ul><li>px: pixel,像素，电子屏幕上组成一幅图画或照片的最基本单元;</li><li>pt: point，点，印刷行业常用单位，等于1/72英寸;</li><li>ppi: pixel per inch，每英寸像素数，该值越高，则屏幕越细腻;</li><li>dpi: dot per inch，每英寸多少点，该值越高，则图片越细腻;</li><li>dp: dip，Density-independent pixel, 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度;</li><li>sp: scale-independent pixel，安卓开发用的字体大小单位。</li></ul><p>ps:具体可参考<a href="http://www.woshipm.com/pmd/176328.html" target="_blank" rel="noopener">八一八那些px、pt、ppi、dpi、dp、sp之间的关系</a></p><h3 id="2-应用图标"><a href="#2-应用图标" class="headerlink" title="2.应用图标"></a>2.应用图标</h3><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/AppIcon.png" alt="AppIcon.png"></p><ul><li>图标尺寸分别为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">40*40</span><br><span class="line">60*60</span><br><span class="line"></span><br><span class="line">58*58</span><br><span class="line">87*87</span><br><span class="line"></span><br><span class="line">80*80</span><br><span class="line">120*120</span><br><span class="line"></span><br><span class="line">120*120</span><br><span class="line">180*180</span><br><span class="line"></span><br><span class="line">1024*1024</span><br></pre></td></tr></table></figure><ul><li>其格式必须为PNG或JPG，最低分辨率为72DPI，并采用RGB色彩空间。</li></ul><p>ps: 具体可参考<a href="https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/image-size-and-resolution/" target="_blank" rel="noopener">Image Size and Resolution</a></p><h3 id="3-启动页"><a href="#3-启动页" class="headerlink" title="3.启动页"></a>3.启动页</h3><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/%E5%90%AF%E5%8A%A8%E9%A1%B5%E5%B0%BA%E5%AF%B8.png" alt="启动页尺寸"></p><ul><li>其格式必须为PNG或JPG，最低分辨率为72DPI，并采用RGB色彩空间。</li><li>因项目中使用LaunchScreen.storyboard加载启动页,需要启动页的图片为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">750px * 1334px</span><br><span class="line">1125px * 2436px</span><br></pre></td></tr></table></figure><p>ps:具体可参考<a href="https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/launch-screen/" target="_blank" rel="noopener">Launch Screen</a></p><h3 id="4-各机型尺寸比较"><a href="#4-各机型尺寸比较" class="headerlink" title="4.各机型尺寸比较"></a>4.各机型尺寸比较</h3><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/iPhone%E6%9C%BA%E5%9E%8B%E5%B0%BA%E5%AF%B8%E6%AF%94%E8%BE%83.png" alt="iPhone机型尺寸比较"></p><ul><li>UI出图以6/6S/7/8为准，即 750 * 1334 px。从中切出的图标即为2x 图，3x图尺寸为2x图的1.5倍。</li></ul><p>ps:具体可参考<a href="https://www.apple.com/cn/iphone/compare/" target="_blank" rel="noopener">iPhone机型比较</a></p><h3 id="5-界面基本组成元素"><a href="#5-界面基本组成元素" class="headerlink" title="5.界面基本组成元素"></a>5.界面基本组成元素</h3><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/iPhone%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6%E5%B0%BA%E5%AF%B8.png" alt="iPhone 界面基础控件尺寸"></p><p>具体控件名称如下：</p><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/%E7%95%8C%E9%9D%A2%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0.png" alt="界面基本组成元素"></p><ul><li>在<code>6/6S/7/8</code>中即像素尺寸为<code>750*1334 px</code>的屏幕中，其状态栏高度为<code>40px</code>(开发尺寸为<code>20pt</code>)，导航栏高度为<code>88px</code>(开发尺寸为<code>44pt</code>)，Tab Bar 高度为<code>98px</code>(开发尺寸为<code>49pt</code>)。</li><li><code>6+/6S+/7+/8+</code> 的状态栏、导航栏、TabBar 高度分别为相应开发尺寸的3倍。</li><li>iPhone X因有刘海儿，其状态栏的开发尺寸高度为<code>44pt</code>(像素尺寸为<code>44 X 3 px</code> )。</li><li>iPhone X没有了Home键，iPhone X的底部预留给系统功能的一个区域-<code>Home Indicator</code>,开发高度<code>34pt</code>（像素尺寸高度<code>34 X 3 px</code>）。</li></ul><p>ps: 具体情况和其他控件尺寸可参考<a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">Human Interface Guidelines</a></p><h3 id="6-图标命名规范"><a href="#6-图标命名规范" class="headerlink" title="6.图标命名规范"></a>6.图标命名规范</h3><p>设计时可以使用6/6S/7/8(像素尺寸：750px  <code>*</code>  1334px)的尺寸作为基准，切图时需要两套图分别为：2x图（750px * 1334px 的UI切片即为2x图）和3x图(尺寸为2x的1.5倍，1x图的3倍)。</p><ul><li>图片格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 普通：image.png</span><br><span class="line">- 两倍图：image@2x.png</span><br><span class="line">- 三倍图：image@3x.png</span><br></pre></td></tr></table></figure><ul><li>保存：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">png-24</span><br><span class="line">保留透明度</span><br></pre></td></tr></table></figure><ul><li>尺寸：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像素,尽量不要出现小数，从750px * 1334px 切下的即为两倍图（@2x）</span><br><span class="line">三倍图为两倍图的1.5倍，为一倍图的3倍。</span><br></pre></td></tr></table></figure><ul><li>命名：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模块_功能_控件_状态@2x.png  或 模块_功能_控件_状态@3x.png</span><br><span class="line"></span><br><span class="line">控件名需要使用英文，比如某个设置列表中的按钮：setting_list_btn_normal@2x.png</span><br><span class="line"></span><br><span class="line">当然切完图后也可以让技术自己命名。</span><br></pre></td></tr></table></figure><h3 id="7-关于iPhone-X"><a href="#7-关于iPhone-X" class="headerlink" title="7.关于iPhone X"></a>7.关于iPhone X</h3><p>iPhone X增加了刘海儿（状态栏开发尺寸高度44pt）和 Home Indicator(开发尺寸高度34pt)。</p><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/iPhoneX%E7%95%8C%E9%9D%A2%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0.png" alt="iPhone X界面基本元素"></p><p>iPhone X的坐标系统以及能显示内容区域如下图：</p><p><img src="/xnxy.github.io/2019/09/09/2017-10-20/iPhoneX%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E5%8F%8A%E8%83%BD%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E5%8C%BA%E5%9F%9F.png" alt="iPhone X的坐标系统以及能显示内容区域"></p><ul><li>设计过程中尽量避免控件被刘海儿和Home Indicator遮住的情况。</li></ul><p>ps: 具体可以参考 <a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">苹果相应文档</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>所有页面中不要出现安卓、Android等其他设备终端的名称，提交审核会被拒。</li><li>所有页面不要出现安卓设备UI控件（如状态栏等），提交审核会被拒。</li><li>App图标不要跟Apple的logo风格相似，提交审核会被拒。</li><li>新应用的icon也不能跟公司其他项目的icon过于相似，提交审核会被拒。</li></ul><p>ps: 具体详情可以参考<a href="https://developer.apple.com/design/tips/cn/" target="_blank" rel="noopener">UI设计注意事项</a>和<a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">Human InterFace Guidelines</a>。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://developer.apple.com/design/tips/cn/" target="_blank" rel="noopener">UI设计注意事项</a></li><li><a href="https://www.apple.com/cn/iphone/compare/" target="_blank" rel="noopener">iPhone机型比较</a></li><li><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">Human InterFace Guidelines</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为方便产品、UI设计师、开发人员在产品细节上达成共识，减少沟通成本，提升开发效率，特整理iOS设备的App设计规范。此规范适用于iOS平台所有App及大多数iOS端网页设计。&lt;/p&gt;
&lt;h3 id=&quot;1-标准单位&quot;&gt;&lt;a href=&quot;#1-标准单位&quot; class=&quot;head
      
    
    </summary>
    
      <category term="随笔" scheme="https://xnxy.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="UI" scheme="https://xnxy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>iOS客户端公共WIFI解决方案探究</title>
    <link href="https://xnxy.github.io/2019/09/09/2017-10-23/"/>
    <id>https://xnxy.github.io/2019/09/09/2017-10-23/</id>
    <published>2019-09-09T11:31:42.000Z</published>
    <updated>2019-09-09T11:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，iOS系统WIFI相应的API极少，而且大部分API为私有接口，一不小心审核就可能被拒。<a href="https://00red.com/blog/2015/01/14/teacher-wifi-solution/" target="_blank" rel="noopener">iOS9之前公共WIFI的解决方案</a>已不适用。在iOS9发布之后，苹果推出了NetworkExtension,其中的NEHotspotHelper可以获取WIFI列表。同样我们也可以根据用户所在的位置，服务器返回用户附近的WIFI列表。</p><h3 id="方案一-：使用NEHotspotHelper获取WIFI列表。"><a href="#方案一-：使用NEHotspotHelper获取WIFI列表。" class="headerlink" title="方案一 ：使用NEHotspotHelper获取WIFI列表。"></a>方案一 ：使用NEHotspotHelper获取WIFI列表。</h3><p>在使用NEHotspotHelper相应API的时候需要申请<a href="https://developer.apple.com/contact/network-extension" target="_blank" rel="noopener">“Network Extension Framework”使用权限</a>，大概需要三周左右。</p><p>相应API可以参考<a href="https://developer.apple.com/documentation/networkextension/nehotspothelper?language=objc" target="_blank" rel="noopener">Developer Documentation</a>，如下所示。</p><p><img src="/xnxy.github.io/2019/09/09/2017-10-23/WIFI.png" alt="NEHotspotNetwork"></p><p>代码实现扫描周围无线网络如下，但在本人测试的过程中因为没申请<a href="https://developer.apple.com/contact/network-extension" target="_blank" rel="noopener">“Network Extension Framework”使用权限</a>的原因，此方法并没返回相应数据，所以并没有获取到设备的WIFI列表(尴尬ing~~)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark --- 扫描周围的无线网络 ---</span><br><span class="line">- (BOOL)scanWifiInfo&#123;</span><br><span class="line"></span><br><span class="line">NSMutableDictionary* options = [[NSMutableDictionary alloc] init];</span><br><span class="line">[options setObject:@&quot;NEHotspotHelper&quot; forKey: kNEHotspotHelperOptionDisplayName];</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;EFNEHotspotHelperDemo&quot;, NULL);</span><br><span class="line"></span><br><span class="line">BOOL returnType = [NEHotspotHelper registerWithOptions: options queue: queue handler: ^(NEHotspotHelperCommand * cmd) &#123;</span><br><span class="line"></span><br><span class="line">NEHotspotNetwork* network;</span><br><span class="line">if (cmd.commandType == kNEHotspotHelperCommandTypeEvaluate || cmd.commandType == kNEHotspotHelperCommandTypeFilterScanList) &#123;</span><br><span class="line">// 遍历 WiFi 列表，打印基本信息</span><br><span class="line">for (network in cmd.networkList) &#123;</span><br><span class="line">NSString* wifiInfoString = [[NSString alloc] initWithFormat: @&quot;SSID: %@\nMac地址: %@\n信号强度: %f\nCommandType:%ld\n\n&quot;,</span><br><span class="line">network.SSID, network.BSSID, network.signalStrength, (long)cmd.commandType];</span><br><span class="line">NSLog(@&quot;------ %@ ------&quot;,wifiInfoString);</span><br><span class="line"></span><br><span class="line">// 检测到指定 WiFi 可设定密码直接连接</span><br><span class="line">if ([network.SSID isEqualToString: @&quot;测试 WiFi&quot;]) &#123;</span><br><span class="line">[network setConfidence: kNEHotspotHelperConfidenceHigh];</span><br><span class="line">[network setPassword: @&quot;测试 WiFi 密码&quot;];</span><br><span class="line">NEHotspotHelperResponse *response = [cmd createResponse: kNEHotspotHelperResultSuccess];</span><br><span class="line">NSLog(@&quot;Response CMD: %@&quot;, response);</span><br><span class="line">[response setNetworkList: @[network]];</span><br><span class="line">[response setNetwork: network];</span><br><span class="line">[response deliver];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return returnType;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用NEHotspotHelper注意事项："><a href="#使用NEHotspotHelper注意事项：" class="headerlink" title="使用NEHotspotHelper注意事项："></a>使用NEHotspotHelper注意事项：</h5><ul><li>需要申请<a href="https://developer.apple.com/contact/network-extension" target="_blank" rel="noopener">“Network Extension Framework”使用权限</a></li><li>需要在Info.plist中添加后台模式权限数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;network-authentication&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure><ul><li>需要将工程中Capabilities的Background Modes开启。</li><li>需要将工程中Capabilities的Wireless Accessory Configuration开启。</li><li>需要在.entitlements中添加HotspotHelper权限代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.apple.developer.networking.HotspotHelper&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;com.apple.external-accessory.wireless-configuration&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p>此方法的缺点：</p><ul><li>只支持iOS 9 + 的设备，系统为iOS 9 以下的设备不支持。</li><li>调用NEHotspotHelper的API需要申请，申请通过后方可使用，否则调用无返回信息。</li><li>有时候会获取不到WIFI列表，需要用户到手机的 设置 -&gt;无线局域网  中开关一次WIFI，进行刷新（特么……）。</li><li>不安全，<a href="http://bobao.360.cn/news/detail/4102.html" target="_blank" rel="noopener">iOS 10.3.1之前的设备可能存在高危漏洞</a>，还有<a href="http://bobao.360.cn/learning/detail/4562.html" target="_blank" rel="noopener">WPA2系列漏洞</a>。</li></ul><p>代码地址：<a href="https://github.com/xnxy/NEHotspotNetwork/tree/master" target="_blank" rel="noopener">NEHotspotNetwork</a></p><h3 id="方案二：根据用户所在位置，服务器返回相应WIFI列表。"><a href="#方案二：根据用户所在位置，服务器返回相应WIFI列表。" class="headerlink" title="方案二：根据用户所在位置，服务器返回相应WIFI列表。"></a>方案二：根据用户所在位置，服务器返回相应WIFI列表。</h3><p>通过上传用户所在地的经纬度，服务端返回用户所在地所有可用的WIFI列表和WIFI密码，然后用户在手机的设置中自己输入相应WIFI密码。</p><p>具体流程：</p><ol><li>客户端获取用户的经纬度上传服务器</li><li>服务器返回用户周围的所有WIFI名称和密码。</li><li>用户在客户端复制WIFI密码。</li><li>到手机的设置 -&gt;无线局域网 中找到相应WIFI 然后粘贴密码。</li></ol><p>缺点：</p><ul><li>需要用户自己到设置中进行操作。</li><li></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.apple.com/library/content/qa/qa1942/_index.html" target="_blank" rel="noopener">iOS Wi-Fi Management APIs</a></li><li><a href="https://developer.apple.com/documentation/networkextension/nehotspothelper?language=objc" target="_blank" rel="noopener">NEHotspotHelper</a></li><li><a href="http://blog.zlcode.com/2016/04/28/network-extension-framework-right-apply/" target="_blank" rel="noopener">申请“Network Extension Framework”使用权利</a></li><li><a href="http://blog.csdn.net/qq_30513483/article/details/61214081" target="_blank" rel="noopener"> iOS 利用 NEHotspotHelper 获取 WiFi 列表</a></li><li><a href="http://bobao.360.cn/news/detail/4102.html" target="_blank" rel="noopener">连个WiFi也能被黑？iOS 10.3 存在高危漏洞，请大家火速升级！</a></li><li><a href="http://bobao.360.cn/learning/detail/4562.html" target="_blank" rel="noopener">KRACK：WPA2系列漏洞事件预警（含技术文章翻译）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，iOS系统WIFI相应的API极少，而且大部分API为私有接口，一不小心审核就可能被拒。&lt;a href=&quot;https://00red.com/blog/2015/01/14/teacher-wifi-solution/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="https://xnxy.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
      <category term="WIFI" scheme="https://xnxy.github.io/tags/WIFI/"/>
    
  </entry>
  
  <entry>
    <title>公司iOS项目MVVM架构模式设计及分析MVVM+RAC的优缺点</title>
    <link href="https://xnxy.github.io/2019/09/09/2017-10-19/"/>
    <id>https://xnxy.github.io/2019/09/09/2017-10-19/</id>
    <published>2019-09-09T11:26:44.000Z</published>
    <updated>2019-09-09T11:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>&emsp;&emsp;这篇博客主要是介绍公司的iOS项目MVVM架构模式的设计及分析MVVM+RAC的优缺点。</p><hr><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p><img src="/xnxy.github.io/2019/09/09/2017-10-19/MVC.png" alt="MVC"></p><blockquote><p>Model   : 实体模型</p><p>View    : UI控件，负责View的绘制及用户的交互。</p><p>Controller : 业务逻辑、数据处理和UI处理</p></blockquote><p>MVC, Model - View - Controller,一个很古老很经典的设计模式，拥有大概50年的历史。而MVC这个架构模式的最大优点就是其概念简单，易于理解，任何一个软件工程毕业的学生都应该在大学课程中学习过。但如果开发过程中使用不当，很可能使大量的代码集中在Controller之中，使Controller变得十分臃肿。</p><hr><h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><p><img src="/xnxy.github.io/2019/09/09/2017-10-19/MVP.png" alt="MVP"></p><blockquote><p>Model   :  实体模型</p><p>View    ：UI控件，负责View的绘制及用户的交互。</p><p>Presenter   : 负责完成View和Model之间的交互与业务逻辑。</p></blockquote><p>MVP, Model - View - Presenter,其实就是将MVC中Controller换成Presenter，是MVC的一个变种。其目的是完全切断View和Model之间的联系，由Presenter充当桥梁对视图和模型进行解耦。</p><hr><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p><img src="/xnxy.github.io/2019/09/09/2017-10-19/MVVM.png" alt="MVVM"></p><blockquote><p>Model   : 实体模型。</p><p>View    : UI控件，负责View的绘制及用户的交互。</p><p>ViewModel :负责View和Model之间的交互，业务逻辑等。</p></blockquote><p>MVVM, Model - View - ViewModel, 一个从MVC模式中演化出来的设计模式。在iOS开发过程中，将原本在Controller中的业务逻辑、数据请求，数据处理 放到ViewModel中，从而有效地减少ViewController中的代码量，减轻ViewController的负担。同时将业务逻辑等放到ViewModel中也方便后期的测试与维护。</p><hr><h2 id="公司MVVM架构模式的设计"><a href="#公司MVVM架构模式的设计" class="headerlink" title="公司MVVM架构模式的设计"></a>公司MVVM架构模式的设计</h2><hr><p>&emsp;&emsp;因为MVVM架构模式的方便测试、维护，复用性高和低耦合等特性，所以公司的项目采用MVVM的架构模式。同时在iOS客户端的开发过程中，我们使用了ReactiveCocoa来实现其绑定机制。</p><h4 id="关于ReactiveCocoa"><a href="#关于ReactiveCocoa" class="headerlink" title="关于ReactiveCocoa"></a>关于ReactiveCocoa</h4><p>&emsp;&emsp; ReactiveCocoa 简称RAC，是由GitHub开源的一个应用于iOS和OS X开发的新框架。集合了函数式编程和响应式编程，所以RAC也被称为函数响应式编程框架（FRP）。</p><p>&emsp;&emsp; 在开发过程中RAC解决了传统开发中状态之间依赖过多、Controller过于臃肿等问题。提供了统一的消息传递机制，降低了类与类之间的耦合度，提高了开发效率。具体使用方法可以参看GitHub中<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa的详细文档</a>。</p><h4 id="公司某项目目录结构"><a href="#公司某项目目录结构" class="headerlink" title="公司某项目目录结构"></a>公司某项目目录结构</h4><p><img src="/xnxy.github.io/2019/09/09/2017-10-19/%E5%85%AC%E5%8F%B8%E6%9F%90%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="公司某项目目录结构"></p><p>项目中的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 第三方sdk(应该用Frameworks)：主要存放一些暂不支持CocoaPods的第三方库。</span><br><span class="line">- Application: 程序的入口文件和配置文件</span><br><span class="line">- BaseClass： 基类、公共扩展类、公共View</span><br><span class="line">- NetWork：网络请求类（对AFNetworking的二次封装）</span><br><span class="line">- Utils: 工具类</span><br><span class="line">- ViewModels：相应模块对应的ViewModel</span><br><span class="line">- Model：实体模型(公司数据结构使用Protobuf，所以Model使用脚本直接生成)</span><br><span class="line">- Views: 相应模块的界面相关（每一个模块对应一个ViewModel）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每种语言发展到一定阶段都会出现相应的依赖管理工具，例如Java的Maven，nodejs的npm，而iOS依赖管理工具是CocoaPods。CocoaPods的出现为我们节省了集成、管理第三方库的时间，所以公司的项目同样使用了CocoaPods管理第三方库。</p><p>&emsp;&emsp;而在数据结构方面我们使用了Google的Protocol Buffer(简称：Protobuf)。而Protobuf是google公司内部的混合语言数据标准，是一种轻便高效的结构化数据存储格式，可以用于结构化数据的序列化。</p><p>&emsp;&emsp;使用时需要先配置开发环境，具体可以查看之前写的一篇博客<a href="http://www.jianshu.com/p/213178307bcf" target="_blank" rel="noopener">《Mac 下配置protobuf（3.2.0）开发环境》</a>。如果使用的是Proto2可以查看另篇博客<a href="http://www.jianshu.com/p/8c6c009bc500" target="_blank" rel="noopener">《ProtocolBuffer for Objective-C 运行环境配置及使用》</a>。</p><hr><h2 id="MVVM-RAC的优缺点"><a href="#MVVM-RAC的优缺点" class="headerlink" title="MVVM + RAC的优缺点"></a>MVVM + RAC的优缺点</h2><hr><p><img src="/xnxy.github.io/2019/09/09/2017-10-19/MCVMVMV.gif" alt="MCVMVMV.gif"></p><p>&emsp;&emsp; RAC和MVVM上面已经介绍过。现在越来越多的项目已经开始使用MVVM的架构模式，同时RAC已经成为MVVM的标配。由上图动画可以看出，对于一个简单的MVC架构的iOS应用，很容易调整到MVVM的。</p><p>&emsp;&emsp;当然在我们享受函数响应式编程框架带来的便捷的同时，也需要承受其带来缺点。但随着自己能力的提高，这些所谓的缺点也会渐渐消失。如果有兴趣也可以查看<a href="https://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="noopener">美团点评技术团队关于RAC的研究</a>，相信你定会有所收获。</p><blockquote><ul><li>优点：</li></ul><p>&emsp;&emsp;1. 方便测试与维护。将业务逻辑、网络请求，数据处理放到ViewModel中便于后期单元测试、维护。</p><p>&emsp;&emsp;2. 低耦合。双向绑定，View可以根据Model的改变而进行修改，一个ViewModel可以绑定到不同的View上。</p><p>&emsp;&emsp;3. 复用性高。可以将一些视图逻辑放到ViewModel中，让很多View重用此视图逻辑等。</p><ul><li>缺点：</li></ul><p>&emsp;&emsp;1. ReactiveCocoa学习成本较高。大部分人对MVVM不太熟悉，基于绑定机制进行编程需要一定的学习成本才能较好的上手。</p><p>&emsp;&emsp;2. 数据绑定使Debug更困难。数据绑定会使程序异常传到其他位置，由上图可以看出，当View上发现bug时，有可能是ViewModel造成的，也可能是Model造成的。</p></blockquote><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://en.wikipedia.org/wiki/Model–view–controller" target="_blank" rel="noopener">Model-View-Controller</a></li><li><a href="https://en.wikipedia.org/wiki/Model–view–presenter" target="_blank" rel="noopener">Model-View-Presenter</a></li><li><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="noopener">Model-View-ViewModel</a></li><li><a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="noopener">ReactiveCocoa and MVVM, an Introduction</a></li><li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a></li><li><a href="http://rxmarbles.com" target="_blank" rel="noopener">RxJS Marbles</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">ProtoBuf开发者指南</a></li><li><a href="https://cocoapods.org" target="_blank" rel="noopener">CocoaPods官网</a></li><li><a href="https://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="noopener">美团点评ReactiveCocoa归档</a></li><li><a href="https://www.zhihu.com/question/20148405" target="_blank" rel="noopener">你对MVC、MVP、MVVM 三种组合模式分别有什么样的理解？</a></li><li><a href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/" target="_blank" rel="noopener">ReactiveCocoa和MVVM入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;这篇博客主要是介绍公司的iOS项目MVVM架构模式的设计及分析MVVM+RAC的优缺点。&lt;/p&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="https://xnxy.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="iOS" scheme="https://xnxy.github.io/tags/iOS/"/>
    
      <category term="架构" scheme="https://xnxy.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
